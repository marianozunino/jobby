// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/marianozunino/cc-backend-go/ent/applicantinterest"
	"github.com/marianozunino/cc-backend-go/ent/applicantprofile"
	"github.com/marianozunino/cc-backend-go/ent/applicantprofileskill"
	"github.com/marianozunino/cc-backend-go/ent/application"
	"github.com/marianozunino/cc-backend-go/ent/category"
	"github.com/marianozunino/cc-backend-go/ent/contactusmessage"
	"github.com/marianozunino/cc-backend-go/ent/degreelevel"
	"github.com/marianozunino/cc-backend-go/ent/education"
	"github.com/marianozunino/cc-backend-go/ent/interview"
	"github.com/marianozunino/cc-backend-go/ent/joboffer"
	"github.com/marianozunino/cc-backend-go/ent/joboffercategory"
	"github.com/marianozunino/cc-backend-go/ent/language"
	"github.com/marianozunino/cc-backend-go/ent/post"
	"github.com/marianozunino/cc-backend-go/ent/postcategory"
	"github.com/marianozunino/cc-backend-go/ent/predicate"
	"github.com/marianozunino/cc-backend-go/ent/skill"
	"github.com/marianozunino/cc-backend-go/ent/status"
	"github.com/marianozunino/cc-backend-go/ent/user"
	"github.com/marianozunino/cc-backend-go/ent/workexperience"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApplicantInterest     = "ApplicantInterest"
	TypeApplicantProfile      = "ApplicantProfile"
	TypeApplicantProfileSkill = "ApplicantProfileSkill"
	TypeApplication           = "Application"
	TypeCategory              = "Category"
	TypeContactUsMessage      = "ContactUsMessage"
	TypeDegreeLevel           = "DegreeLevel"
	TypeEducation             = "Education"
	TypeInterview             = "Interview"
	TypeJobOffer              = "JobOffer"
	TypeJobOfferCategory      = "JobOfferCategory"
	TypeLanguage              = "Language"
	TypePost                  = "Post"
	TypePostCategory          = "PostCategory"
	TypeSkill                 = "Skill"
	TypeStatus                = "Status"
	TypeUser                  = "User"
	TypeWorkExperience        = "WorkExperience"
)

// ApplicantInterestMutation represents an operation that mutates the ApplicantInterest nodes in the graph.
type ApplicantInterestMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	applicant_profile        *uuid.UUID
	clearedapplicant_profile bool
	category                 *uuid.UUID
	clearedcategory          bool
	done                     bool
	oldValue                 func(context.Context) (*ApplicantInterest, error)
	predicates               []predicate.ApplicantInterest
}

var _ ent.Mutation = (*ApplicantInterestMutation)(nil)

// applicantinterestOption allows management of the mutation configuration using functional options.
type applicantinterestOption func(*ApplicantInterestMutation)

// newApplicantInterestMutation creates new mutation for the ApplicantInterest entity.
func newApplicantInterestMutation(c config, op Op, opts ...applicantinterestOption) *ApplicantInterestMutation {
	m := &ApplicantInterestMutation{
		config:        c,
		op:            op,
		typ:           TypeApplicantInterest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicantInterestID sets the ID field of the mutation.
func withApplicantInterestID(id uuid.UUID) applicantinterestOption {
	return func(m *ApplicantInterestMutation) {
		var (
			err   error
			once  sync.Once
			value *ApplicantInterest
		)
		m.oldValue = func(ctx context.Context) (*ApplicantInterest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApplicantInterest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplicantInterest sets the old ApplicantInterest of the mutation.
func withApplicantInterest(node *ApplicantInterest) applicantinterestOption {
	return func(m *ApplicantInterestMutation) {
		m.oldValue = func(context.Context) (*ApplicantInterest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicantInterestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicantInterestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApplicantInterest entities.
func (m *ApplicantInterestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicantInterestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicantInterestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApplicantInterest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCategoryID sets the "category_id" field.
func (m *ApplicantInterestMutation) SetCategoryID(u uuid.UUID) {
	m.category = &u
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *ApplicantInterestMutation) CategoryID() (r uuid.UUID, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the ApplicantInterest entity.
// If the ApplicantInterest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantInterestMutation) OldCategoryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *ApplicantInterestMutation) ResetCategoryID() {
	m.category = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApplicantInterestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApplicantInterestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApplicantInterest entity.
// If the ApplicantInterest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantInterestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ApplicantInterestMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[applicantinterest.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ApplicantInterestMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[applicantinterest.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApplicantInterestMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, applicantinterest.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApplicantInterestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApplicantInterestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApplicantInterest entity.
// If the ApplicantInterest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantInterestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ApplicantInterestMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[applicantinterest.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ApplicantInterestMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[applicantinterest.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApplicantInterestMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, applicantinterest.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ApplicantInterestMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ApplicantInterestMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ApplicantInterest entity.
// If the ApplicantInterest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantInterestMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ApplicantInterestMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[applicantinterest.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ApplicantInterestMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[applicantinterest.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ApplicantInterestMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, applicantinterest.FieldDeletedAt)
}

// SetApplicantProfileID sets the "applicant_profile_id" field.
func (m *ApplicantInterestMutation) SetApplicantProfileID(u uuid.UUID) {
	m.applicant_profile = &u
}

// ApplicantProfileID returns the value of the "applicant_profile_id" field in the mutation.
func (m *ApplicantInterestMutation) ApplicantProfileID() (r uuid.UUID, exists bool) {
	v := m.applicant_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicantProfileID returns the old "applicant_profile_id" field's value of the ApplicantInterest entity.
// If the ApplicantInterest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantInterestMutation) OldApplicantProfileID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicantProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicantProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicantProfileID: %w", err)
	}
	return oldValue.ApplicantProfileID, nil
}

// ResetApplicantProfileID resets all changes to the "applicant_profile_id" field.
func (m *ApplicantInterestMutation) ResetApplicantProfileID() {
	m.applicant_profile = nil
}

// ClearApplicantProfile clears the "applicant_profile" edge to the ApplicantProfile entity.
func (m *ApplicantInterestMutation) ClearApplicantProfile() {
	m.clearedapplicant_profile = true
}

// ApplicantProfileCleared reports if the "applicant_profile" edge to the ApplicantProfile entity was cleared.
func (m *ApplicantInterestMutation) ApplicantProfileCleared() bool {
	return m.clearedapplicant_profile
}

// ApplicantProfileIDs returns the "applicant_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicantProfileID instead. It exists only for internal usage by the builders.
func (m *ApplicantInterestMutation) ApplicantProfileIDs() (ids []uuid.UUID) {
	if id := m.applicant_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplicantProfile resets all changes to the "applicant_profile" edge.
func (m *ApplicantInterestMutation) ResetApplicantProfile() {
	m.applicant_profile = nil
	m.clearedapplicant_profile = false
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *ApplicantInterestMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *ApplicantInterestMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *ApplicantInterestMutation) CategoryIDs() (ids []uuid.UUID) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *ApplicantInterestMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Where appends a list predicates to the ApplicantInterestMutation builder.
func (m *ApplicantInterestMutation) Where(ps ...predicate.ApplicantInterest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicantInterestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicantInterestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApplicantInterest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicantInterestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicantInterestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApplicantInterest).
func (m *ApplicantInterestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicantInterestMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.category != nil {
		fields = append(fields, applicantinterest.FieldCategoryID)
	}
	if m.created_at != nil {
		fields = append(fields, applicantinterest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, applicantinterest.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, applicantinterest.FieldDeletedAt)
	}
	if m.applicant_profile != nil {
		fields = append(fields, applicantinterest.FieldApplicantProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicantInterestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case applicantinterest.FieldCategoryID:
		return m.CategoryID()
	case applicantinterest.FieldCreatedAt:
		return m.CreatedAt()
	case applicantinterest.FieldUpdatedAt:
		return m.UpdatedAt()
	case applicantinterest.FieldDeletedAt:
		return m.DeletedAt()
	case applicantinterest.FieldApplicantProfileID:
		return m.ApplicantProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicantInterestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case applicantinterest.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case applicantinterest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case applicantinterest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case applicantinterest.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case applicantinterest.FieldApplicantProfileID:
		return m.OldApplicantProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown ApplicantInterest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicantInterestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case applicantinterest.FieldCategoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case applicantinterest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case applicantinterest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case applicantinterest.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case applicantinterest.FieldApplicantProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicantProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown ApplicantInterest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicantInterestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicantInterestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicantInterestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApplicantInterest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicantInterestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(applicantinterest.FieldCreatedAt) {
		fields = append(fields, applicantinterest.FieldCreatedAt)
	}
	if m.FieldCleared(applicantinterest.FieldUpdatedAt) {
		fields = append(fields, applicantinterest.FieldUpdatedAt)
	}
	if m.FieldCleared(applicantinterest.FieldDeletedAt) {
		fields = append(fields, applicantinterest.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicantInterestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicantInterestMutation) ClearField(name string) error {
	switch name {
	case applicantinterest.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case applicantinterest.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case applicantinterest.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ApplicantInterest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicantInterestMutation) ResetField(name string) error {
	switch name {
	case applicantinterest.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case applicantinterest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case applicantinterest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case applicantinterest.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case applicantinterest.FieldApplicantProfileID:
		m.ResetApplicantProfileID()
		return nil
	}
	return fmt.Errorf("unknown ApplicantInterest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicantInterestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.applicant_profile != nil {
		edges = append(edges, applicantinterest.EdgeApplicantProfile)
	}
	if m.category != nil {
		edges = append(edges, applicantinterest.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicantInterestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case applicantinterest.EdgeApplicantProfile:
		if id := m.applicant_profile; id != nil {
			return []ent.Value{*id}
		}
	case applicantinterest.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicantInterestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicantInterestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicantInterestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapplicant_profile {
		edges = append(edges, applicantinterest.EdgeApplicantProfile)
	}
	if m.clearedcategory {
		edges = append(edges, applicantinterest.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicantInterestMutation) EdgeCleared(name string) bool {
	switch name {
	case applicantinterest.EdgeApplicantProfile:
		return m.clearedapplicant_profile
	case applicantinterest.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicantInterestMutation) ClearEdge(name string) error {
	switch name {
	case applicantinterest.EdgeApplicantProfile:
		m.ClearApplicantProfile()
		return nil
	case applicantinterest.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown ApplicantInterest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicantInterestMutation) ResetEdge(name string) error {
	switch name {
	case applicantinterest.EdgeApplicantProfile:
		m.ResetApplicantProfile()
		return nil
	case applicantinterest.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown ApplicantInterest edge %s", name)
}

// ApplicantProfileMutation represents an operation that mutates the ApplicantProfile nodes in the graph.
type ApplicantProfileMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	birthday                        *time.Time
	gender                          *string
	phone                           *string
	address1                        *string
	address2                        *string
	cv                              *string
	internal_comments               *string
	receive_emails                  *bool
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	extra_skills                    *struct{}
	clearedFields                   map[string]struct{}
	applicant_interests             map[uuid.UUID]struct{}
	removedapplicant_interests      map[uuid.UUID]struct{}
	clearedapplicant_interests      bool
	applicant_profile_skills        map[uuid.UUID]struct{}
	removedapplicant_profile_skills map[uuid.UUID]struct{}
	clearedapplicant_profile_skills bool
	user                            *uuid.UUID
	cleareduser                     bool
	applications                    map[uuid.UUID]struct{}
	removedapplications             map[uuid.UUID]struct{}
	clearedapplications             bool
	educations                      map[uuid.UUID]struct{}
	removededucations               map[uuid.UUID]struct{}
	clearededucations               bool
	languages                       map[uint]struct{}
	removedlanguages                map[uint]struct{}
	clearedlanguages                bool
	work_experiences                map[uuid.UUID]struct{}
	removedwork_experiences         map[uuid.UUID]struct{}
	clearedwork_experiences         bool
	done                            bool
	oldValue                        func(context.Context) (*ApplicantProfile, error)
	predicates                      []predicate.ApplicantProfile
}

var _ ent.Mutation = (*ApplicantProfileMutation)(nil)

// applicantprofileOption allows management of the mutation configuration using functional options.
type applicantprofileOption func(*ApplicantProfileMutation)

// newApplicantProfileMutation creates new mutation for the ApplicantProfile entity.
func newApplicantProfileMutation(c config, op Op, opts ...applicantprofileOption) *ApplicantProfileMutation {
	m := &ApplicantProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeApplicantProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicantProfileID sets the ID field of the mutation.
func withApplicantProfileID(id uuid.UUID) applicantprofileOption {
	return func(m *ApplicantProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *ApplicantProfile
		)
		m.oldValue = func(ctx context.Context) (*ApplicantProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApplicantProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplicantProfile sets the old ApplicantProfile of the mutation.
func withApplicantProfile(node *ApplicantProfile) applicantprofileOption {
	return func(m *ApplicantProfileMutation) {
		m.oldValue = func(context.Context) (*ApplicantProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicantProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicantProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApplicantProfile entities.
func (m *ApplicantProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicantProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicantProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApplicantProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBirthday sets the "birthday" field.
func (m *ApplicantProfileMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *ApplicantProfileMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *ApplicantProfileMutation) ResetBirthday() {
	m.birthday = nil
}

// SetGender sets the "gender" field.
func (m *ApplicantProfileMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *ApplicantProfileMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *ApplicantProfileMutation) ResetGender() {
	m.gender = nil
}

// SetPhone sets the "phone" field.
func (m *ApplicantProfileMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ApplicantProfileMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *ApplicantProfileMutation) ResetPhone() {
	m.phone = nil
}

// SetAddress1 sets the "address1" field.
func (m *ApplicantProfileMutation) SetAddress1(s string) {
	m.address1 = &s
}

// Address1 returns the value of the "address1" field in the mutation.
func (m *ApplicantProfileMutation) Address1() (r string, exists bool) {
	v := m.address1
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress1 returns the old "address1" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldAddress1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress1: %w", err)
	}
	return oldValue.Address1, nil
}

// ResetAddress1 resets all changes to the "address1" field.
func (m *ApplicantProfileMutation) ResetAddress1() {
	m.address1 = nil
}

// SetAddress2 sets the "address2" field.
func (m *ApplicantProfileMutation) SetAddress2(s string) {
	m.address2 = &s
}

// Address2 returns the value of the "address2" field in the mutation.
func (m *ApplicantProfileMutation) Address2() (r string, exists bool) {
	v := m.address2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress2 returns the old "address2" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldAddress2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress2: %w", err)
	}
	return oldValue.Address2, nil
}

// ResetAddress2 resets all changes to the "address2" field.
func (m *ApplicantProfileMutation) ResetAddress2() {
	m.address2 = nil
}

// SetCv sets the "cv" field.
func (m *ApplicantProfileMutation) SetCv(s string) {
	m.cv = &s
}

// Cv returns the value of the "cv" field in the mutation.
func (m *ApplicantProfileMutation) Cv() (r string, exists bool) {
	v := m.cv
	if v == nil {
		return
	}
	return *v, true
}

// OldCv returns the old "cv" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldCv(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCv: %w", err)
	}
	return oldValue.Cv, nil
}

// ClearCv clears the value of the "cv" field.
func (m *ApplicantProfileMutation) ClearCv() {
	m.cv = nil
	m.clearedFields[applicantprofile.FieldCv] = struct{}{}
}

// CvCleared returns if the "cv" field was cleared in this mutation.
func (m *ApplicantProfileMutation) CvCleared() bool {
	_, ok := m.clearedFields[applicantprofile.FieldCv]
	return ok
}

// ResetCv resets all changes to the "cv" field.
func (m *ApplicantProfileMutation) ResetCv() {
	m.cv = nil
	delete(m.clearedFields, applicantprofile.FieldCv)
}

// SetInternalComments sets the "internal_comments" field.
func (m *ApplicantProfileMutation) SetInternalComments(s string) {
	m.internal_comments = &s
}

// InternalComments returns the value of the "internal_comments" field in the mutation.
func (m *ApplicantProfileMutation) InternalComments() (r string, exists bool) {
	v := m.internal_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalComments returns the old "internal_comments" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldInternalComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalComments: %w", err)
	}
	return oldValue.InternalComments, nil
}

// ResetInternalComments resets all changes to the "internal_comments" field.
func (m *ApplicantProfileMutation) ResetInternalComments() {
	m.internal_comments = nil
}

// SetReceiveEmails sets the "receive_emails" field.
func (m *ApplicantProfileMutation) SetReceiveEmails(b bool) {
	m.receive_emails = &b
}

// ReceiveEmails returns the value of the "receive_emails" field in the mutation.
func (m *ApplicantProfileMutation) ReceiveEmails() (r bool, exists bool) {
	v := m.receive_emails
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiveEmails returns the old "receive_emails" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldReceiveEmails(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiveEmails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiveEmails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiveEmails: %w", err)
	}
	return oldValue.ReceiveEmails, nil
}

// ResetReceiveEmails resets all changes to the "receive_emails" field.
func (m *ApplicantProfileMutation) ResetReceiveEmails() {
	m.receive_emails = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApplicantProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApplicantProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ApplicantProfileMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[applicantprofile.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ApplicantProfileMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[applicantprofile.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApplicantProfileMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, applicantprofile.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApplicantProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApplicantProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ApplicantProfileMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[applicantprofile.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ApplicantProfileMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[applicantprofile.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApplicantProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, applicantprofile.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ApplicantProfileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ApplicantProfileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ApplicantProfileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[applicantprofile.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ApplicantProfileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[applicantprofile.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ApplicantProfileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, applicantprofile.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *ApplicantProfileMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ApplicantProfileMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldUserID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ApplicantProfileMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[applicantprofile.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ApplicantProfileMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[applicantprofile.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ApplicantProfileMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, applicantprofile.FieldUserID)
}

// SetExtraSkills sets the "extra_skills" field.
func (m *ApplicantProfileMutation) SetExtraSkills(s struct{}) {
	m.extra_skills = &s
}

// ExtraSkills returns the value of the "extra_skills" field in the mutation.
func (m *ApplicantProfileMutation) ExtraSkills() (r struct{}, exists bool) {
	v := m.extra_skills
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraSkills returns the old "extra_skills" field's value of the ApplicantProfile entity.
// If the ApplicantProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileMutation) OldExtraSkills(ctx context.Context) (v struct{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraSkills: %w", err)
	}
	return oldValue.ExtraSkills, nil
}

// ClearExtraSkills clears the value of the "extra_skills" field.
func (m *ApplicantProfileMutation) ClearExtraSkills() {
	m.extra_skills = nil
	m.clearedFields[applicantprofile.FieldExtraSkills] = struct{}{}
}

// ExtraSkillsCleared returns if the "extra_skills" field was cleared in this mutation.
func (m *ApplicantProfileMutation) ExtraSkillsCleared() bool {
	_, ok := m.clearedFields[applicantprofile.FieldExtraSkills]
	return ok
}

// ResetExtraSkills resets all changes to the "extra_skills" field.
func (m *ApplicantProfileMutation) ResetExtraSkills() {
	m.extra_skills = nil
	delete(m.clearedFields, applicantprofile.FieldExtraSkills)
}

// AddApplicantInterestIDs adds the "applicant_interests" edge to the ApplicantInterest entity by ids.
func (m *ApplicantProfileMutation) AddApplicantInterestIDs(ids ...uuid.UUID) {
	if m.applicant_interests == nil {
		m.applicant_interests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applicant_interests[ids[i]] = struct{}{}
	}
}

// ClearApplicantInterests clears the "applicant_interests" edge to the ApplicantInterest entity.
func (m *ApplicantProfileMutation) ClearApplicantInterests() {
	m.clearedapplicant_interests = true
}

// ApplicantInterestsCleared reports if the "applicant_interests" edge to the ApplicantInterest entity was cleared.
func (m *ApplicantProfileMutation) ApplicantInterestsCleared() bool {
	return m.clearedapplicant_interests
}

// RemoveApplicantInterestIDs removes the "applicant_interests" edge to the ApplicantInterest entity by IDs.
func (m *ApplicantProfileMutation) RemoveApplicantInterestIDs(ids ...uuid.UUID) {
	if m.removedapplicant_interests == nil {
		m.removedapplicant_interests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applicant_interests, ids[i])
		m.removedapplicant_interests[ids[i]] = struct{}{}
	}
}

// RemovedApplicantInterests returns the removed IDs of the "applicant_interests" edge to the ApplicantInterest entity.
func (m *ApplicantProfileMutation) RemovedApplicantInterestsIDs() (ids []uuid.UUID) {
	for id := range m.removedapplicant_interests {
		ids = append(ids, id)
	}
	return
}

// ApplicantInterestsIDs returns the "applicant_interests" edge IDs in the mutation.
func (m *ApplicantProfileMutation) ApplicantInterestsIDs() (ids []uuid.UUID) {
	for id := range m.applicant_interests {
		ids = append(ids, id)
	}
	return
}

// ResetApplicantInterests resets all changes to the "applicant_interests" edge.
func (m *ApplicantProfileMutation) ResetApplicantInterests() {
	m.applicant_interests = nil
	m.clearedapplicant_interests = false
	m.removedapplicant_interests = nil
}

// AddApplicantProfileSkillIDs adds the "applicant_profile_skills" edge to the ApplicantProfileSkill entity by ids.
func (m *ApplicantProfileMutation) AddApplicantProfileSkillIDs(ids ...uuid.UUID) {
	if m.applicant_profile_skills == nil {
		m.applicant_profile_skills = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applicant_profile_skills[ids[i]] = struct{}{}
	}
}

// ClearApplicantProfileSkills clears the "applicant_profile_skills" edge to the ApplicantProfileSkill entity.
func (m *ApplicantProfileMutation) ClearApplicantProfileSkills() {
	m.clearedapplicant_profile_skills = true
}

// ApplicantProfileSkillsCleared reports if the "applicant_profile_skills" edge to the ApplicantProfileSkill entity was cleared.
func (m *ApplicantProfileMutation) ApplicantProfileSkillsCleared() bool {
	return m.clearedapplicant_profile_skills
}

// RemoveApplicantProfileSkillIDs removes the "applicant_profile_skills" edge to the ApplicantProfileSkill entity by IDs.
func (m *ApplicantProfileMutation) RemoveApplicantProfileSkillIDs(ids ...uuid.UUID) {
	if m.removedapplicant_profile_skills == nil {
		m.removedapplicant_profile_skills = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applicant_profile_skills, ids[i])
		m.removedapplicant_profile_skills[ids[i]] = struct{}{}
	}
}

// RemovedApplicantProfileSkills returns the removed IDs of the "applicant_profile_skills" edge to the ApplicantProfileSkill entity.
func (m *ApplicantProfileMutation) RemovedApplicantProfileSkillsIDs() (ids []uuid.UUID) {
	for id := range m.removedapplicant_profile_skills {
		ids = append(ids, id)
	}
	return
}

// ApplicantProfileSkillsIDs returns the "applicant_profile_skills" edge IDs in the mutation.
func (m *ApplicantProfileMutation) ApplicantProfileSkillsIDs() (ids []uuid.UUID) {
	for id := range m.applicant_profile_skills {
		ids = append(ids, id)
	}
	return
}

// ResetApplicantProfileSkills resets all changes to the "applicant_profile_skills" edge.
func (m *ApplicantProfileMutation) ResetApplicantProfileSkills() {
	m.applicant_profile_skills = nil
	m.clearedapplicant_profile_skills = false
	m.removedapplicant_profile_skills = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ApplicantProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ApplicantProfileMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ApplicantProfileMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ApplicantProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *ApplicantProfileMutation) AddApplicationIDs(ids ...uuid.UUID) {
	if m.applications == nil {
		m.applications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *ApplicantProfileMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *ApplicantProfileMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *ApplicantProfileMutation) RemoveApplicationIDs(ids ...uuid.UUID) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *ApplicantProfileMutation) RemovedApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *ApplicantProfileMutation) ApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *ApplicantProfileMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// AddEducationIDs adds the "educations" edge to the Education entity by ids.
func (m *ApplicantProfileMutation) AddEducationIDs(ids ...uuid.UUID) {
	if m.educations == nil {
		m.educations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.educations[ids[i]] = struct{}{}
	}
}

// ClearEducations clears the "educations" edge to the Education entity.
func (m *ApplicantProfileMutation) ClearEducations() {
	m.clearededucations = true
}

// EducationsCleared reports if the "educations" edge to the Education entity was cleared.
func (m *ApplicantProfileMutation) EducationsCleared() bool {
	return m.clearededucations
}

// RemoveEducationIDs removes the "educations" edge to the Education entity by IDs.
func (m *ApplicantProfileMutation) RemoveEducationIDs(ids ...uuid.UUID) {
	if m.removededucations == nil {
		m.removededucations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.educations, ids[i])
		m.removededucations[ids[i]] = struct{}{}
	}
}

// RemovedEducations returns the removed IDs of the "educations" edge to the Education entity.
func (m *ApplicantProfileMutation) RemovedEducationsIDs() (ids []uuid.UUID) {
	for id := range m.removededucations {
		ids = append(ids, id)
	}
	return
}

// EducationsIDs returns the "educations" edge IDs in the mutation.
func (m *ApplicantProfileMutation) EducationsIDs() (ids []uuid.UUID) {
	for id := range m.educations {
		ids = append(ids, id)
	}
	return
}

// ResetEducations resets all changes to the "educations" edge.
func (m *ApplicantProfileMutation) ResetEducations() {
	m.educations = nil
	m.clearededucations = false
	m.removededucations = nil
}

// AddLanguageIDs adds the "languages" edge to the Language entity by ids.
func (m *ApplicantProfileMutation) AddLanguageIDs(ids ...uint) {
	if m.languages == nil {
		m.languages = make(map[uint]struct{})
	}
	for i := range ids {
		m.languages[ids[i]] = struct{}{}
	}
}

// ClearLanguages clears the "languages" edge to the Language entity.
func (m *ApplicantProfileMutation) ClearLanguages() {
	m.clearedlanguages = true
}

// LanguagesCleared reports if the "languages" edge to the Language entity was cleared.
func (m *ApplicantProfileMutation) LanguagesCleared() bool {
	return m.clearedlanguages
}

// RemoveLanguageIDs removes the "languages" edge to the Language entity by IDs.
func (m *ApplicantProfileMutation) RemoveLanguageIDs(ids ...uint) {
	if m.removedlanguages == nil {
		m.removedlanguages = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.languages, ids[i])
		m.removedlanguages[ids[i]] = struct{}{}
	}
}

// RemovedLanguages returns the removed IDs of the "languages" edge to the Language entity.
func (m *ApplicantProfileMutation) RemovedLanguagesIDs() (ids []uint) {
	for id := range m.removedlanguages {
		ids = append(ids, id)
	}
	return
}

// LanguagesIDs returns the "languages" edge IDs in the mutation.
func (m *ApplicantProfileMutation) LanguagesIDs() (ids []uint) {
	for id := range m.languages {
		ids = append(ids, id)
	}
	return
}

// ResetLanguages resets all changes to the "languages" edge.
func (m *ApplicantProfileMutation) ResetLanguages() {
	m.languages = nil
	m.clearedlanguages = false
	m.removedlanguages = nil
}

// AddWorkExperienceIDs adds the "work_experiences" edge to the WorkExperience entity by ids.
func (m *ApplicantProfileMutation) AddWorkExperienceIDs(ids ...uuid.UUID) {
	if m.work_experiences == nil {
		m.work_experiences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.work_experiences[ids[i]] = struct{}{}
	}
}

// ClearWorkExperiences clears the "work_experiences" edge to the WorkExperience entity.
func (m *ApplicantProfileMutation) ClearWorkExperiences() {
	m.clearedwork_experiences = true
}

// WorkExperiencesCleared reports if the "work_experiences" edge to the WorkExperience entity was cleared.
func (m *ApplicantProfileMutation) WorkExperiencesCleared() bool {
	return m.clearedwork_experiences
}

// RemoveWorkExperienceIDs removes the "work_experiences" edge to the WorkExperience entity by IDs.
func (m *ApplicantProfileMutation) RemoveWorkExperienceIDs(ids ...uuid.UUID) {
	if m.removedwork_experiences == nil {
		m.removedwork_experiences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.work_experiences, ids[i])
		m.removedwork_experiences[ids[i]] = struct{}{}
	}
}

// RemovedWorkExperiences returns the removed IDs of the "work_experiences" edge to the WorkExperience entity.
func (m *ApplicantProfileMutation) RemovedWorkExperiencesIDs() (ids []uuid.UUID) {
	for id := range m.removedwork_experiences {
		ids = append(ids, id)
	}
	return
}

// WorkExperiencesIDs returns the "work_experiences" edge IDs in the mutation.
func (m *ApplicantProfileMutation) WorkExperiencesIDs() (ids []uuid.UUID) {
	for id := range m.work_experiences {
		ids = append(ids, id)
	}
	return
}

// ResetWorkExperiences resets all changes to the "work_experiences" edge.
func (m *ApplicantProfileMutation) ResetWorkExperiences() {
	m.work_experiences = nil
	m.clearedwork_experiences = false
	m.removedwork_experiences = nil
}

// Where appends a list predicates to the ApplicantProfileMutation builder.
func (m *ApplicantProfileMutation) Where(ps ...predicate.ApplicantProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicantProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicantProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApplicantProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicantProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicantProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApplicantProfile).
func (m *ApplicantProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicantProfileMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.birthday != nil {
		fields = append(fields, applicantprofile.FieldBirthday)
	}
	if m.gender != nil {
		fields = append(fields, applicantprofile.FieldGender)
	}
	if m.phone != nil {
		fields = append(fields, applicantprofile.FieldPhone)
	}
	if m.address1 != nil {
		fields = append(fields, applicantprofile.FieldAddress1)
	}
	if m.address2 != nil {
		fields = append(fields, applicantprofile.FieldAddress2)
	}
	if m.cv != nil {
		fields = append(fields, applicantprofile.FieldCv)
	}
	if m.internal_comments != nil {
		fields = append(fields, applicantprofile.FieldInternalComments)
	}
	if m.receive_emails != nil {
		fields = append(fields, applicantprofile.FieldReceiveEmails)
	}
	if m.created_at != nil {
		fields = append(fields, applicantprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, applicantprofile.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, applicantprofile.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, applicantprofile.FieldUserID)
	}
	if m.extra_skills != nil {
		fields = append(fields, applicantprofile.FieldExtraSkills)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicantProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case applicantprofile.FieldBirthday:
		return m.Birthday()
	case applicantprofile.FieldGender:
		return m.Gender()
	case applicantprofile.FieldPhone:
		return m.Phone()
	case applicantprofile.FieldAddress1:
		return m.Address1()
	case applicantprofile.FieldAddress2:
		return m.Address2()
	case applicantprofile.FieldCv:
		return m.Cv()
	case applicantprofile.FieldInternalComments:
		return m.InternalComments()
	case applicantprofile.FieldReceiveEmails:
		return m.ReceiveEmails()
	case applicantprofile.FieldCreatedAt:
		return m.CreatedAt()
	case applicantprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case applicantprofile.FieldDeletedAt:
		return m.DeletedAt()
	case applicantprofile.FieldUserID:
		return m.UserID()
	case applicantprofile.FieldExtraSkills:
		return m.ExtraSkills()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicantProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case applicantprofile.FieldBirthday:
		return m.OldBirthday(ctx)
	case applicantprofile.FieldGender:
		return m.OldGender(ctx)
	case applicantprofile.FieldPhone:
		return m.OldPhone(ctx)
	case applicantprofile.FieldAddress1:
		return m.OldAddress1(ctx)
	case applicantprofile.FieldAddress2:
		return m.OldAddress2(ctx)
	case applicantprofile.FieldCv:
		return m.OldCv(ctx)
	case applicantprofile.FieldInternalComments:
		return m.OldInternalComments(ctx)
	case applicantprofile.FieldReceiveEmails:
		return m.OldReceiveEmails(ctx)
	case applicantprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case applicantprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case applicantprofile.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case applicantprofile.FieldUserID:
		return m.OldUserID(ctx)
	case applicantprofile.FieldExtraSkills:
		return m.OldExtraSkills(ctx)
	}
	return nil, fmt.Errorf("unknown ApplicantProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicantProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case applicantprofile.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case applicantprofile.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case applicantprofile.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case applicantprofile.FieldAddress1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress1(v)
		return nil
	case applicantprofile.FieldAddress2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress2(v)
		return nil
	case applicantprofile.FieldCv:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCv(v)
		return nil
	case applicantprofile.FieldInternalComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalComments(v)
		return nil
	case applicantprofile.FieldReceiveEmails:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiveEmails(v)
		return nil
	case applicantprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case applicantprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case applicantprofile.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case applicantprofile.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case applicantprofile.FieldExtraSkills:
		v, ok := value.(struct{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraSkills(v)
		return nil
	}
	return fmt.Errorf("unknown ApplicantProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicantProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicantProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicantProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApplicantProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicantProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(applicantprofile.FieldCv) {
		fields = append(fields, applicantprofile.FieldCv)
	}
	if m.FieldCleared(applicantprofile.FieldCreatedAt) {
		fields = append(fields, applicantprofile.FieldCreatedAt)
	}
	if m.FieldCleared(applicantprofile.FieldUpdatedAt) {
		fields = append(fields, applicantprofile.FieldUpdatedAt)
	}
	if m.FieldCleared(applicantprofile.FieldDeletedAt) {
		fields = append(fields, applicantprofile.FieldDeletedAt)
	}
	if m.FieldCleared(applicantprofile.FieldUserID) {
		fields = append(fields, applicantprofile.FieldUserID)
	}
	if m.FieldCleared(applicantprofile.FieldExtraSkills) {
		fields = append(fields, applicantprofile.FieldExtraSkills)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicantProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicantProfileMutation) ClearField(name string) error {
	switch name {
	case applicantprofile.FieldCv:
		m.ClearCv()
		return nil
	case applicantprofile.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case applicantprofile.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case applicantprofile.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case applicantprofile.FieldUserID:
		m.ClearUserID()
		return nil
	case applicantprofile.FieldExtraSkills:
		m.ClearExtraSkills()
		return nil
	}
	return fmt.Errorf("unknown ApplicantProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicantProfileMutation) ResetField(name string) error {
	switch name {
	case applicantprofile.FieldBirthday:
		m.ResetBirthday()
		return nil
	case applicantprofile.FieldGender:
		m.ResetGender()
		return nil
	case applicantprofile.FieldPhone:
		m.ResetPhone()
		return nil
	case applicantprofile.FieldAddress1:
		m.ResetAddress1()
		return nil
	case applicantprofile.FieldAddress2:
		m.ResetAddress2()
		return nil
	case applicantprofile.FieldCv:
		m.ResetCv()
		return nil
	case applicantprofile.FieldInternalComments:
		m.ResetInternalComments()
		return nil
	case applicantprofile.FieldReceiveEmails:
		m.ResetReceiveEmails()
		return nil
	case applicantprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case applicantprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case applicantprofile.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case applicantprofile.FieldUserID:
		m.ResetUserID()
		return nil
	case applicantprofile.FieldExtraSkills:
		m.ResetExtraSkills()
		return nil
	}
	return fmt.Errorf("unknown ApplicantProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicantProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.applicant_interests != nil {
		edges = append(edges, applicantprofile.EdgeApplicantInterests)
	}
	if m.applicant_profile_skills != nil {
		edges = append(edges, applicantprofile.EdgeApplicantProfileSkills)
	}
	if m.user != nil {
		edges = append(edges, applicantprofile.EdgeUser)
	}
	if m.applications != nil {
		edges = append(edges, applicantprofile.EdgeApplications)
	}
	if m.educations != nil {
		edges = append(edges, applicantprofile.EdgeEducations)
	}
	if m.languages != nil {
		edges = append(edges, applicantprofile.EdgeLanguages)
	}
	if m.work_experiences != nil {
		edges = append(edges, applicantprofile.EdgeWorkExperiences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicantProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case applicantprofile.EdgeApplicantInterests:
		ids := make([]ent.Value, 0, len(m.applicant_interests))
		for id := range m.applicant_interests {
			ids = append(ids, id)
		}
		return ids
	case applicantprofile.EdgeApplicantProfileSkills:
		ids := make([]ent.Value, 0, len(m.applicant_profile_skills))
		for id := range m.applicant_profile_skills {
			ids = append(ids, id)
		}
		return ids
	case applicantprofile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case applicantprofile.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case applicantprofile.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.educations))
		for id := range m.educations {
			ids = append(ids, id)
		}
		return ids
	case applicantprofile.EdgeLanguages:
		ids := make([]ent.Value, 0, len(m.languages))
		for id := range m.languages {
			ids = append(ids, id)
		}
		return ids
	case applicantprofile.EdgeWorkExperiences:
		ids := make([]ent.Value, 0, len(m.work_experiences))
		for id := range m.work_experiences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicantProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedapplicant_interests != nil {
		edges = append(edges, applicantprofile.EdgeApplicantInterests)
	}
	if m.removedapplicant_profile_skills != nil {
		edges = append(edges, applicantprofile.EdgeApplicantProfileSkills)
	}
	if m.removedapplications != nil {
		edges = append(edges, applicantprofile.EdgeApplications)
	}
	if m.removededucations != nil {
		edges = append(edges, applicantprofile.EdgeEducations)
	}
	if m.removedlanguages != nil {
		edges = append(edges, applicantprofile.EdgeLanguages)
	}
	if m.removedwork_experiences != nil {
		edges = append(edges, applicantprofile.EdgeWorkExperiences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicantProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case applicantprofile.EdgeApplicantInterests:
		ids := make([]ent.Value, 0, len(m.removedapplicant_interests))
		for id := range m.removedapplicant_interests {
			ids = append(ids, id)
		}
		return ids
	case applicantprofile.EdgeApplicantProfileSkills:
		ids := make([]ent.Value, 0, len(m.removedapplicant_profile_skills))
		for id := range m.removedapplicant_profile_skills {
			ids = append(ids, id)
		}
		return ids
	case applicantprofile.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	case applicantprofile.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.removededucations))
		for id := range m.removededucations {
			ids = append(ids, id)
		}
		return ids
	case applicantprofile.EdgeLanguages:
		ids := make([]ent.Value, 0, len(m.removedlanguages))
		for id := range m.removedlanguages {
			ids = append(ids, id)
		}
		return ids
	case applicantprofile.EdgeWorkExperiences:
		ids := make([]ent.Value, 0, len(m.removedwork_experiences))
		for id := range m.removedwork_experiences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicantProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedapplicant_interests {
		edges = append(edges, applicantprofile.EdgeApplicantInterests)
	}
	if m.clearedapplicant_profile_skills {
		edges = append(edges, applicantprofile.EdgeApplicantProfileSkills)
	}
	if m.cleareduser {
		edges = append(edges, applicantprofile.EdgeUser)
	}
	if m.clearedapplications {
		edges = append(edges, applicantprofile.EdgeApplications)
	}
	if m.clearededucations {
		edges = append(edges, applicantprofile.EdgeEducations)
	}
	if m.clearedlanguages {
		edges = append(edges, applicantprofile.EdgeLanguages)
	}
	if m.clearedwork_experiences {
		edges = append(edges, applicantprofile.EdgeWorkExperiences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicantProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case applicantprofile.EdgeApplicantInterests:
		return m.clearedapplicant_interests
	case applicantprofile.EdgeApplicantProfileSkills:
		return m.clearedapplicant_profile_skills
	case applicantprofile.EdgeUser:
		return m.cleareduser
	case applicantprofile.EdgeApplications:
		return m.clearedapplications
	case applicantprofile.EdgeEducations:
		return m.clearededucations
	case applicantprofile.EdgeLanguages:
		return m.clearedlanguages
	case applicantprofile.EdgeWorkExperiences:
		return m.clearedwork_experiences
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicantProfileMutation) ClearEdge(name string) error {
	switch name {
	case applicantprofile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ApplicantProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicantProfileMutation) ResetEdge(name string) error {
	switch name {
	case applicantprofile.EdgeApplicantInterests:
		m.ResetApplicantInterests()
		return nil
	case applicantprofile.EdgeApplicantProfileSkills:
		m.ResetApplicantProfileSkills()
		return nil
	case applicantprofile.EdgeUser:
		m.ResetUser()
		return nil
	case applicantprofile.EdgeApplications:
		m.ResetApplications()
		return nil
	case applicantprofile.EdgeEducations:
		m.ResetEducations()
		return nil
	case applicantprofile.EdgeLanguages:
		m.ResetLanguages()
		return nil
	case applicantprofile.EdgeWorkExperiences:
		m.ResetWorkExperiences()
		return nil
	}
	return fmt.Errorf("unknown ApplicantProfile edge %s", name)
}

// ApplicantProfileSkillMutation represents an operation that mutates the ApplicantProfileSkill nodes in the graph.
type ApplicantProfileSkillMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	level                    *applicantprofileskill.Level
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	applicant_profile        *uuid.UUID
	clearedapplicant_profile bool
	skill                    *uuid.UUID
	clearedskill             bool
	done                     bool
	oldValue                 func(context.Context) (*ApplicantProfileSkill, error)
	predicates               []predicate.ApplicantProfileSkill
}

var _ ent.Mutation = (*ApplicantProfileSkillMutation)(nil)

// applicantprofileskillOption allows management of the mutation configuration using functional options.
type applicantprofileskillOption func(*ApplicantProfileSkillMutation)

// newApplicantProfileSkillMutation creates new mutation for the ApplicantProfileSkill entity.
func newApplicantProfileSkillMutation(c config, op Op, opts ...applicantprofileskillOption) *ApplicantProfileSkillMutation {
	m := &ApplicantProfileSkillMutation{
		config:        c,
		op:            op,
		typ:           TypeApplicantProfileSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicantProfileSkillID sets the ID field of the mutation.
func withApplicantProfileSkillID(id uuid.UUID) applicantprofileskillOption {
	return func(m *ApplicantProfileSkillMutation) {
		var (
			err   error
			once  sync.Once
			value *ApplicantProfileSkill
		)
		m.oldValue = func(ctx context.Context) (*ApplicantProfileSkill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApplicantProfileSkill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplicantProfileSkill sets the old ApplicantProfileSkill of the mutation.
func withApplicantProfileSkill(node *ApplicantProfileSkill) applicantprofileskillOption {
	return func(m *ApplicantProfileSkillMutation) {
		m.oldValue = func(context.Context) (*ApplicantProfileSkill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicantProfileSkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicantProfileSkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApplicantProfileSkill entities.
func (m *ApplicantProfileSkillMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicantProfileSkillMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicantProfileSkillMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApplicantProfileSkill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplicantProfileID sets the "applicant_profile_id" field.
func (m *ApplicantProfileSkillMutation) SetApplicantProfileID(u uuid.UUID) {
	m.applicant_profile = &u
}

// ApplicantProfileID returns the value of the "applicant_profile_id" field in the mutation.
func (m *ApplicantProfileSkillMutation) ApplicantProfileID() (r uuid.UUID, exists bool) {
	v := m.applicant_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicantProfileID returns the old "applicant_profile_id" field's value of the ApplicantProfileSkill entity.
// If the ApplicantProfileSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileSkillMutation) OldApplicantProfileID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicantProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicantProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicantProfileID: %w", err)
	}
	return oldValue.ApplicantProfileID, nil
}

// ResetApplicantProfileID resets all changes to the "applicant_profile_id" field.
func (m *ApplicantProfileSkillMutation) ResetApplicantProfileID() {
	m.applicant_profile = nil
}

// SetLevel sets the "level" field.
func (m *ApplicantProfileSkillMutation) SetLevel(a applicantprofileskill.Level) {
	m.level = &a
}

// Level returns the value of the "level" field in the mutation.
func (m *ApplicantProfileSkillMutation) Level() (r applicantprofileskill.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the ApplicantProfileSkill entity.
// If the ApplicantProfileSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileSkillMutation) OldLevel(ctx context.Context) (v applicantprofileskill.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *ApplicantProfileSkillMutation) ResetLevel() {
	m.level = nil
}

// SetSkillID sets the "skill_id" field.
func (m *ApplicantProfileSkillMutation) SetSkillID(u uuid.UUID) {
	m.skill = &u
}

// SkillID returns the value of the "skill_id" field in the mutation.
func (m *ApplicantProfileSkillMutation) SkillID() (r uuid.UUID, exists bool) {
	v := m.skill
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillID returns the old "skill_id" field's value of the ApplicantProfileSkill entity.
// If the ApplicantProfileSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileSkillMutation) OldSkillID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillID: %w", err)
	}
	return oldValue.SkillID, nil
}

// ClearSkillID clears the value of the "skill_id" field.
func (m *ApplicantProfileSkillMutation) ClearSkillID() {
	m.skill = nil
	m.clearedFields[applicantprofileskill.FieldSkillID] = struct{}{}
}

// SkillIDCleared returns if the "skill_id" field was cleared in this mutation.
func (m *ApplicantProfileSkillMutation) SkillIDCleared() bool {
	_, ok := m.clearedFields[applicantprofileskill.FieldSkillID]
	return ok
}

// ResetSkillID resets all changes to the "skill_id" field.
func (m *ApplicantProfileSkillMutation) ResetSkillID() {
	m.skill = nil
	delete(m.clearedFields, applicantprofileskill.FieldSkillID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ApplicantProfileSkillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApplicantProfileSkillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApplicantProfileSkill entity.
// If the ApplicantProfileSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileSkillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApplicantProfileSkillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApplicantProfileSkillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApplicantProfileSkillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApplicantProfileSkill entity.
// If the ApplicantProfileSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileSkillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApplicantProfileSkillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ApplicantProfileSkillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ApplicantProfileSkillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ApplicantProfileSkill entity.
// If the ApplicantProfileSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantProfileSkillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ApplicantProfileSkillMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[applicantprofileskill.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ApplicantProfileSkillMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[applicantprofileskill.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ApplicantProfileSkillMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, applicantprofileskill.FieldDeletedAt)
}

// ClearApplicantProfile clears the "applicant_profile" edge to the ApplicantProfile entity.
func (m *ApplicantProfileSkillMutation) ClearApplicantProfile() {
	m.clearedapplicant_profile = true
}

// ApplicantProfileCleared reports if the "applicant_profile" edge to the ApplicantProfile entity was cleared.
func (m *ApplicantProfileSkillMutation) ApplicantProfileCleared() bool {
	return m.clearedapplicant_profile
}

// ApplicantProfileIDs returns the "applicant_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicantProfileID instead. It exists only for internal usage by the builders.
func (m *ApplicantProfileSkillMutation) ApplicantProfileIDs() (ids []uuid.UUID) {
	if id := m.applicant_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplicantProfile resets all changes to the "applicant_profile" edge.
func (m *ApplicantProfileSkillMutation) ResetApplicantProfile() {
	m.applicant_profile = nil
	m.clearedapplicant_profile = false
}

// ClearSkill clears the "skill" edge to the Skill entity.
func (m *ApplicantProfileSkillMutation) ClearSkill() {
	m.clearedskill = true
}

// SkillCleared reports if the "skill" edge to the Skill entity was cleared.
func (m *ApplicantProfileSkillMutation) SkillCleared() bool {
	return m.SkillIDCleared() || m.clearedskill
}

// SkillIDs returns the "skill" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SkillID instead. It exists only for internal usage by the builders.
func (m *ApplicantProfileSkillMutation) SkillIDs() (ids []uuid.UUID) {
	if id := m.skill; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSkill resets all changes to the "skill" edge.
func (m *ApplicantProfileSkillMutation) ResetSkill() {
	m.skill = nil
	m.clearedskill = false
}

// Where appends a list predicates to the ApplicantProfileSkillMutation builder.
func (m *ApplicantProfileSkillMutation) Where(ps ...predicate.ApplicantProfileSkill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicantProfileSkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicantProfileSkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApplicantProfileSkill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicantProfileSkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicantProfileSkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApplicantProfileSkill).
func (m *ApplicantProfileSkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicantProfileSkillMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.applicant_profile != nil {
		fields = append(fields, applicantprofileskill.FieldApplicantProfileID)
	}
	if m.level != nil {
		fields = append(fields, applicantprofileskill.FieldLevel)
	}
	if m.skill != nil {
		fields = append(fields, applicantprofileskill.FieldSkillID)
	}
	if m.created_at != nil {
		fields = append(fields, applicantprofileskill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, applicantprofileskill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, applicantprofileskill.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicantProfileSkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case applicantprofileskill.FieldApplicantProfileID:
		return m.ApplicantProfileID()
	case applicantprofileskill.FieldLevel:
		return m.Level()
	case applicantprofileskill.FieldSkillID:
		return m.SkillID()
	case applicantprofileskill.FieldCreatedAt:
		return m.CreatedAt()
	case applicantprofileskill.FieldUpdatedAt:
		return m.UpdatedAt()
	case applicantprofileskill.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicantProfileSkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case applicantprofileskill.FieldApplicantProfileID:
		return m.OldApplicantProfileID(ctx)
	case applicantprofileskill.FieldLevel:
		return m.OldLevel(ctx)
	case applicantprofileskill.FieldSkillID:
		return m.OldSkillID(ctx)
	case applicantprofileskill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case applicantprofileskill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case applicantprofileskill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ApplicantProfileSkill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicantProfileSkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case applicantprofileskill.FieldApplicantProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicantProfileID(v)
		return nil
	case applicantprofileskill.FieldLevel:
		v, ok := value.(applicantprofileskill.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case applicantprofileskill.FieldSkillID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillID(v)
		return nil
	case applicantprofileskill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case applicantprofileskill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case applicantprofileskill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ApplicantProfileSkill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicantProfileSkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicantProfileSkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicantProfileSkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApplicantProfileSkill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicantProfileSkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(applicantprofileskill.FieldSkillID) {
		fields = append(fields, applicantprofileskill.FieldSkillID)
	}
	if m.FieldCleared(applicantprofileskill.FieldDeletedAt) {
		fields = append(fields, applicantprofileskill.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicantProfileSkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicantProfileSkillMutation) ClearField(name string) error {
	switch name {
	case applicantprofileskill.FieldSkillID:
		m.ClearSkillID()
		return nil
	case applicantprofileskill.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ApplicantProfileSkill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicantProfileSkillMutation) ResetField(name string) error {
	switch name {
	case applicantprofileskill.FieldApplicantProfileID:
		m.ResetApplicantProfileID()
		return nil
	case applicantprofileskill.FieldLevel:
		m.ResetLevel()
		return nil
	case applicantprofileskill.FieldSkillID:
		m.ResetSkillID()
		return nil
	case applicantprofileskill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case applicantprofileskill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case applicantprofileskill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ApplicantProfileSkill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicantProfileSkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.applicant_profile != nil {
		edges = append(edges, applicantprofileskill.EdgeApplicantProfile)
	}
	if m.skill != nil {
		edges = append(edges, applicantprofileskill.EdgeSkill)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicantProfileSkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case applicantprofileskill.EdgeApplicantProfile:
		if id := m.applicant_profile; id != nil {
			return []ent.Value{*id}
		}
	case applicantprofileskill.EdgeSkill:
		if id := m.skill; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicantProfileSkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicantProfileSkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicantProfileSkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapplicant_profile {
		edges = append(edges, applicantprofileskill.EdgeApplicantProfile)
	}
	if m.clearedskill {
		edges = append(edges, applicantprofileskill.EdgeSkill)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicantProfileSkillMutation) EdgeCleared(name string) bool {
	switch name {
	case applicantprofileskill.EdgeApplicantProfile:
		return m.clearedapplicant_profile
	case applicantprofileskill.EdgeSkill:
		return m.clearedskill
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicantProfileSkillMutation) ClearEdge(name string) error {
	switch name {
	case applicantprofileskill.EdgeApplicantProfile:
		m.ClearApplicantProfile()
		return nil
	case applicantprofileskill.EdgeSkill:
		m.ClearSkill()
		return nil
	}
	return fmt.Errorf("unknown ApplicantProfileSkill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicantProfileSkillMutation) ResetEdge(name string) error {
	switch name {
	case applicantprofileskill.EdgeApplicantProfile:
		m.ResetApplicantProfile()
		return nil
	case applicantprofileskill.EdgeSkill:
		m.ResetSkill()
		return nil
	}
	return fmt.Errorf("unknown ApplicantProfileSkill edge %s", name)
}

// ApplicationMutation represents an operation that mutates the Application nodes in the graph.
type ApplicationMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	applicant_profile        *uuid.UUID
	clearedapplicant_profile bool
	job_offer                *uuid.UUID
	clearedjob_offer         bool
	interviews               map[uuid.UUID]struct{}
	removedinterviews        map[uuid.UUID]struct{}
	clearedinterviews        bool
	done                     bool
	oldValue                 func(context.Context) (*Application, error)
	predicates               []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows management of the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for the Application entity.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the ID field of the mutation.
func withApplicationID(id uuid.UUID) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Application entities.
func (m *ApplicationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Application.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJobOfferID sets the "job_offer_id" field.
func (m *ApplicationMutation) SetJobOfferID(u uuid.UUID) {
	m.job_offer = &u
}

// JobOfferID returns the value of the "job_offer_id" field in the mutation.
func (m *ApplicationMutation) JobOfferID() (r uuid.UUID, exists bool) {
	v := m.job_offer
	if v == nil {
		return
	}
	return *v, true
}

// OldJobOfferID returns the old "job_offer_id" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldJobOfferID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobOfferID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobOfferID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobOfferID: %w", err)
	}
	return oldValue.JobOfferID, nil
}

// ResetJobOfferID resets all changes to the "job_offer_id" field.
func (m *ApplicationMutation) ResetJobOfferID() {
	m.job_offer = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApplicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApplicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ApplicationMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[application.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ApplicationMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[application.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApplicationMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, application.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApplicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApplicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ApplicationMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[application.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ApplicationMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[application.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApplicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, application.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ApplicationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ApplicationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ApplicationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[application.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ApplicationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[application.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ApplicationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, application.FieldDeletedAt)
}

// SetApplicantProfileID sets the "applicant_profile_id" field.
func (m *ApplicationMutation) SetApplicantProfileID(u uuid.UUID) {
	m.applicant_profile = &u
}

// ApplicantProfileID returns the value of the "applicant_profile_id" field in the mutation.
func (m *ApplicationMutation) ApplicantProfileID() (r uuid.UUID, exists bool) {
	v := m.applicant_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicantProfileID returns the old "applicant_profile_id" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldApplicantProfileID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicantProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicantProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicantProfileID: %w", err)
	}
	return oldValue.ApplicantProfileID, nil
}

// ResetApplicantProfileID resets all changes to the "applicant_profile_id" field.
func (m *ApplicationMutation) ResetApplicantProfileID() {
	m.applicant_profile = nil
}

// ClearApplicantProfile clears the "applicant_profile" edge to the ApplicantProfile entity.
func (m *ApplicationMutation) ClearApplicantProfile() {
	m.clearedapplicant_profile = true
}

// ApplicantProfileCleared reports if the "applicant_profile" edge to the ApplicantProfile entity was cleared.
func (m *ApplicationMutation) ApplicantProfileCleared() bool {
	return m.clearedapplicant_profile
}

// ApplicantProfileIDs returns the "applicant_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicantProfileID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) ApplicantProfileIDs() (ids []uuid.UUID) {
	if id := m.applicant_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplicantProfile resets all changes to the "applicant_profile" edge.
func (m *ApplicationMutation) ResetApplicantProfile() {
	m.applicant_profile = nil
	m.clearedapplicant_profile = false
}

// ClearJobOffer clears the "job_offer" edge to the JobOffer entity.
func (m *ApplicationMutation) ClearJobOffer() {
	m.clearedjob_offer = true
}

// JobOfferCleared reports if the "job_offer" edge to the JobOffer entity was cleared.
func (m *ApplicationMutation) JobOfferCleared() bool {
	return m.clearedjob_offer
}

// JobOfferIDs returns the "job_offer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobOfferID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) JobOfferIDs() (ids []uuid.UUID) {
	if id := m.job_offer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobOffer resets all changes to the "job_offer" edge.
func (m *ApplicationMutation) ResetJobOffer() {
	m.job_offer = nil
	m.clearedjob_offer = false
}

// AddInterviewIDs adds the "interviews" edge to the Interview entity by ids.
func (m *ApplicationMutation) AddInterviewIDs(ids ...uuid.UUID) {
	if m.interviews == nil {
		m.interviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.interviews[ids[i]] = struct{}{}
	}
}

// ClearInterviews clears the "interviews" edge to the Interview entity.
func (m *ApplicationMutation) ClearInterviews() {
	m.clearedinterviews = true
}

// InterviewsCleared reports if the "interviews" edge to the Interview entity was cleared.
func (m *ApplicationMutation) InterviewsCleared() bool {
	return m.clearedinterviews
}

// RemoveInterviewIDs removes the "interviews" edge to the Interview entity by IDs.
func (m *ApplicationMutation) RemoveInterviewIDs(ids ...uuid.UUID) {
	if m.removedinterviews == nil {
		m.removedinterviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.interviews, ids[i])
		m.removedinterviews[ids[i]] = struct{}{}
	}
}

// RemovedInterviews returns the removed IDs of the "interviews" edge to the Interview entity.
func (m *ApplicationMutation) RemovedInterviewsIDs() (ids []uuid.UUID) {
	for id := range m.removedinterviews {
		ids = append(ids, id)
	}
	return
}

// InterviewsIDs returns the "interviews" edge IDs in the mutation.
func (m *ApplicationMutation) InterviewsIDs() (ids []uuid.UUID) {
	for id := range m.interviews {
		ids = append(ids, id)
	}
	return
}

// ResetInterviews resets all changes to the "interviews" edge.
func (m *ApplicationMutation) ResetInterviews() {
	m.interviews = nil
	m.clearedinterviews = false
	m.removedinterviews = nil
}

// Where appends a list predicates to the ApplicationMutation builder.
func (m *ApplicationMutation) Where(ps ...predicate.Application) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Application, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.job_offer != nil {
		fields = append(fields, application.FieldJobOfferID)
	}
	if m.created_at != nil {
		fields = append(fields, application.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, application.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, application.FieldDeletedAt)
	}
	if m.applicant_profile != nil {
		fields = append(fields, application.FieldApplicantProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldJobOfferID:
		return m.JobOfferID()
	case application.FieldCreatedAt:
		return m.CreatedAt()
	case application.FieldUpdatedAt:
		return m.UpdatedAt()
	case application.FieldDeletedAt:
		return m.DeletedAt()
	case application.FieldApplicantProfileID:
		return m.ApplicantProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldJobOfferID:
		return m.OldJobOfferID(ctx)
	case application.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case application.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case application.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case application.FieldApplicantProfileID:
		return m.OldApplicantProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldJobOfferID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobOfferID(v)
		return nil
	case application.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case application.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case application.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case application.FieldApplicantProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicantProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(application.FieldCreatedAt) {
		fields = append(fields, application.FieldCreatedAt)
	}
	if m.FieldCleared(application.FieldUpdatedAt) {
		fields = append(fields, application.FieldUpdatedAt)
	}
	if m.FieldCleared(application.FieldDeletedAt) {
		fields = append(fields, application.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	switch name {
	case application.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case application.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case application.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldJobOfferID:
		m.ResetJobOfferID()
		return nil
	case application.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case application.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case application.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case application.FieldApplicantProfileID:
		m.ResetApplicantProfileID()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.applicant_profile != nil {
		edges = append(edges, application.EdgeApplicantProfile)
	}
	if m.job_offer != nil {
		edges = append(edges, application.EdgeJobOffer)
	}
	if m.interviews != nil {
		edges = append(edges, application.EdgeInterviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeApplicantProfile:
		if id := m.applicant_profile; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeJobOffer:
		if id := m.job_offer; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeInterviews:
		ids := make([]ent.Value, 0, len(m.interviews))
		for id := range m.interviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedinterviews != nil {
		edges = append(edges, application.EdgeInterviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeInterviews:
		ids := make([]ent.Value, 0, len(m.removedinterviews))
		for id := range m.removedinterviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapplicant_profile {
		edges = append(edges, application.EdgeApplicantProfile)
	}
	if m.clearedjob_offer {
		edges = append(edges, application.EdgeJobOffer)
	}
	if m.clearedinterviews {
		edges = append(edges, application.EdgeInterviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeApplicantProfile:
		return m.clearedapplicant_profile
	case application.EdgeJobOffer:
		return m.clearedjob_offer
	case application.EdgeInterviews:
		return m.clearedinterviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	case application.EdgeApplicantProfile:
		m.ClearApplicantProfile()
		return nil
	case application.EdgeJobOffer:
		m.ClearJobOffer()
		return nil
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeApplicantProfile:
		m.ResetApplicantProfile()
		return nil
	case application.EdgeJobOffer:
		m.ResetJobOffer()
		return nil
	case application.EdgeInterviews:
		m.ResetInterviews()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	name                        *string
	slug                        *string
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	is_root                     *bool
	clearedFields               map[string]struct{}
	applicant_interests         map[uuid.UUID]struct{}
	removedapplicant_interests  map[uuid.UUID]struct{}
	clearedapplicant_interests  bool
	child_categories            map[uuid.UUID]struct{}
	removedchild_categories     map[uuid.UUID]struct{}
	clearedchild_categories     bool
	parent_category             *uuid.UUID
	clearedparent_category      bool
	job_offer_categories        map[uuid.UUID]struct{}
	removedjob_offer_categories map[uuid.UUID]struct{}
	clearedjob_offer_categories bool
	done                        bool
	oldValue                    func(context.Context) (*Category, error)
	predicates                  []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id uuid.UUID) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetParentID sets the "parent_id" field.
func (m *CategoryMutation) SetParentID(u uuid.UUID) {
	m.parent_category = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CategoryMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.parent_category
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CategoryMutation) ClearParentID() {
	m.parent_category = nil
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[category.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CategoryMutation) ResetParentID() {
	m.parent_category = nil
	delete(m.clearedFields, category.FieldParentID)
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *CategoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[category.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *CategoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[category.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, category.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CategoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[category.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CategoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[category.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, category.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[category.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[category.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, category.FieldDeletedAt)
}

// SetIsRoot sets the "is_root" field.
func (m *CategoryMutation) SetIsRoot(b bool) {
	m.is_root = &b
}

// IsRoot returns the value of the "is_root" field in the mutation.
func (m *CategoryMutation) IsRoot() (r bool, exists bool) {
	v := m.is_root
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRoot returns the old "is_root" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldIsRoot(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRoot: %w", err)
	}
	return oldValue.IsRoot, nil
}

// ResetIsRoot resets all changes to the "is_root" field.
func (m *CategoryMutation) ResetIsRoot() {
	m.is_root = nil
}

// AddApplicantInterestIDs adds the "applicant_interests" edge to the ApplicantInterest entity by ids.
func (m *CategoryMutation) AddApplicantInterestIDs(ids ...uuid.UUID) {
	if m.applicant_interests == nil {
		m.applicant_interests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applicant_interests[ids[i]] = struct{}{}
	}
}

// ClearApplicantInterests clears the "applicant_interests" edge to the ApplicantInterest entity.
func (m *CategoryMutation) ClearApplicantInterests() {
	m.clearedapplicant_interests = true
}

// ApplicantInterestsCleared reports if the "applicant_interests" edge to the ApplicantInterest entity was cleared.
func (m *CategoryMutation) ApplicantInterestsCleared() bool {
	return m.clearedapplicant_interests
}

// RemoveApplicantInterestIDs removes the "applicant_interests" edge to the ApplicantInterest entity by IDs.
func (m *CategoryMutation) RemoveApplicantInterestIDs(ids ...uuid.UUID) {
	if m.removedapplicant_interests == nil {
		m.removedapplicant_interests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applicant_interests, ids[i])
		m.removedapplicant_interests[ids[i]] = struct{}{}
	}
}

// RemovedApplicantInterests returns the removed IDs of the "applicant_interests" edge to the ApplicantInterest entity.
func (m *CategoryMutation) RemovedApplicantInterestsIDs() (ids []uuid.UUID) {
	for id := range m.removedapplicant_interests {
		ids = append(ids, id)
	}
	return
}

// ApplicantInterestsIDs returns the "applicant_interests" edge IDs in the mutation.
func (m *CategoryMutation) ApplicantInterestsIDs() (ids []uuid.UUID) {
	for id := range m.applicant_interests {
		ids = append(ids, id)
	}
	return
}

// ResetApplicantInterests resets all changes to the "applicant_interests" edge.
func (m *CategoryMutation) ResetApplicantInterests() {
	m.applicant_interests = nil
	m.clearedapplicant_interests = false
	m.removedapplicant_interests = nil
}

// AddChildCategoryIDs adds the "child_categories" edge to the Category entity by ids.
func (m *CategoryMutation) AddChildCategoryIDs(ids ...uuid.UUID) {
	if m.child_categories == nil {
		m.child_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.child_categories[ids[i]] = struct{}{}
	}
}

// ClearChildCategories clears the "child_categories" edge to the Category entity.
func (m *CategoryMutation) ClearChildCategories() {
	m.clearedchild_categories = true
}

// ChildCategoriesCleared reports if the "child_categories" edge to the Category entity was cleared.
func (m *CategoryMutation) ChildCategoriesCleared() bool {
	return m.clearedchild_categories
}

// RemoveChildCategoryIDs removes the "child_categories" edge to the Category entity by IDs.
func (m *CategoryMutation) RemoveChildCategoryIDs(ids ...uuid.UUID) {
	if m.removedchild_categories == nil {
		m.removedchild_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.child_categories, ids[i])
		m.removedchild_categories[ids[i]] = struct{}{}
	}
}

// RemovedChildCategories returns the removed IDs of the "child_categories" edge to the Category entity.
func (m *CategoryMutation) RemovedChildCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedchild_categories {
		ids = append(ids, id)
	}
	return
}

// ChildCategoriesIDs returns the "child_categories" edge IDs in the mutation.
func (m *CategoryMutation) ChildCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.child_categories {
		ids = append(ids, id)
	}
	return
}

// ResetChildCategories resets all changes to the "child_categories" edge.
func (m *CategoryMutation) ResetChildCategories() {
	m.child_categories = nil
	m.clearedchild_categories = false
	m.removedchild_categories = nil
}

// SetParentCategoryID sets the "parent_category" edge to the Category entity by id.
func (m *CategoryMutation) SetParentCategoryID(id uuid.UUID) {
	m.parent_category = &id
}

// ClearParentCategory clears the "parent_category" edge to the Category entity.
func (m *CategoryMutation) ClearParentCategory() {
	m.clearedparent_category = true
}

// ParentCategoryCleared reports if the "parent_category" edge to the Category entity was cleared.
func (m *CategoryMutation) ParentCategoryCleared() bool {
	return m.ParentIDCleared() || m.clearedparent_category
}

// ParentCategoryID returns the "parent_category" edge ID in the mutation.
func (m *CategoryMutation) ParentCategoryID() (id uuid.UUID, exists bool) {
	if m.parent_category != nil {
		return *m.parent_category, true
	}
	return
}

// ParentCategoryIDs returns the "parent_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentCategoryID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentCategoryIDs() (ids []uuid.UUID) {
	if id := m.parent_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentCategory resets all changes to the "parent_category" edge.
func (m *CategoryMutation) ResetParentCategory() {
	m.parent_category = nil
	m.clearedparent_category = false
}

// AddJobOfferCategoryIDs adds the "job_offer_categories" edge to the JobOfferCategory entity by ids.
func (m *CategoryMutation) AddJobOfferCategoryIDs(ids ...uuid.UUID) {
	if m.job_offer_categories == nil {
		m.job_offer_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.job_offer_categories[ids[i]] = struct{}{}
	}
}

// ClearJobOfferCategories clears the "job_offer_categories" edge to the JobOfferCategory entity.
func (m *CategoryMutation) ClearJobOfferCategories() {
	m.clearedjob_offer_categories = true
}

// JobOfferCategoriesCleared reports if the "job_offer_categories" edge to the JobOfferCategory entity was cleared.
func (m *CategoryMutation) JobOfferCategoriesCleared() bool {
	return m.clearedjob_offer_categories
}

// RemoveJobOfferCategoryIDs removes the "job_offer_categories" edge to the JobOfferCategory entity by IDs.
func (m *CategoryMutation) RemoveJobOfferCategoryIDs(ids ...uuid.UUID) {
	if m.removedjob_offer_categories == nil {
		m.removedjob_offer_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.job_offer_categories, ids[i])
		m.removedjob_offer_categories[ids[i]] = struct{}{}
	}
}

// RemovedJobOfferCategories returns the removed IDs of the "job_offer_categories" edge to the JobOfferCategory entity.
func (m *CategoryMutation) RemovedJobOfferCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedjob_offer_categories {
		ids = append(ids, id)
	}
	return
}

// JobOfferCategoriesIDs returns the "job_offer_categories" edge IDs in the mutation.
func (m *CategoryMutation) JobOfferCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.job_offer_categories {
		ids = append(ids, id)
	}
	return
}

// ResetJobOfferCategories resets all changes to the "job_offer_categories" edge.
func (m *CategoryMutation) ResetJobOfferCategories() {
	m.job_offer_categories = nil
	m.clearedjob_offer_categories = false
	m.removedjob_offer_categories = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.parent_category != nil {
		fields = append(fields, category.FieldParentID)
	}
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.is_root != nil {
		fields = append(fields, category.FieldIsRoot)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldParentID:
		return m.ParentID()
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldDeletedAt:
		return m.DeletedAt()
	case category.FieldIsRoot:
		return m.IsRoot()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldParentID:
		return m.OldParentID(ctx)
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case category.FieldIsRoot:
		return m.OldIsRoot(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case category.FieldIsRoot:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRoot(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldParentID) {
		fields = append(fields, category.FieldParentID)
	}
	if m.FieldCleared(category.FieldCreatedAt) {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.FieldCleared(category.FieldUpdatedAt) {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.FieldCleared(category.FieldDeletedAt) {
		fields = append(fields, category.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldParentID:
		m.ClearParentID()
		return nil
	case category.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case category.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldParentID:
		m.ResetParentID()
		return nil
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case category.FieldIsRoot:
		m.ResetIsRoot()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.applicant_interests != nil {
		edges = append(edges, category.EdgeApplicantInterests)
	}
	if m.child_categories != nil {
		edges = append(edges, category.EdgeChildCategories)
	}
	if m.parent_category != nil {
		edges = append(edges, category.EdgeParentCategory)
	}
	if m.job_offer_categories != nil {
		edges = append(edges, category.EdgeJobOfferCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeApplicantInterests:
		ids := make([]ent.Value, 0, len(m.applicant_interests))
		for id := range m.applicant_interests {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeChildCategories:
		ids := make([]ent.Value, 0, len(m.child_categories))
		for id := range m.child_categories {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeParentCategory:
		if id := m.parent_category; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeJobOfferCategories:
		ids := make([]ent.Value, 0, len(m.job_offer_categories))
		for id := range m.job_offer_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedapplicant_interests != nil {
		edges = append(edges, category.EdgeApplicantInterests)
	}
	if m.removedchild_categories != nil {
		edges = append(edges, category.EdgeChildCategories)
	}
	if m.removedjob_offer_categories != nil {
		edges = append(edges, category.EdgeJobOfferCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeApplicantInterests:
		ids := make([]ent.Value, 0, len(m.removedapplicant_interests))
		for id := range m.removedapplicant_interests {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeChildCategories:
		ids := make([]ent.Value, 0, len(m.removedchild_categories))
		for id := range m.removedchild_categories {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeJobOfferCategories:
		ids := make([]ent.Value, 0, len(m.removedjob_offer_categories))
		for id := range m.removedjob_offer_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedapplicant_interests {
		edges = append(edges, category.EdgeApplicantInterests)
	}
	if m.clearedchild_categories {
		edges = append(edges, category.EdgeChildCategories)
	}
	if m.clearedparent_category {
		edges = append(edges, category.EdgeParentCategory)
	}
	if m.clearedjob_offer_categories {
		edges = append(edges, category.EdgeJobOfferCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeApplicantInterests:
		return m.clearedapplicant_interests
	case category.EdgeChildCategories:
		return m.clearedchild_categories
	case category.EdgeParentCategory:
		return m.clearedparent_category
	case category.EdgeJobOfferCategories:
		return m.clearedjob_offer_categories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeParentCategory:
		m.ClearParentCategory()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeApplicantInterests:
		m.ResetApplicantInterests()
		return nil
	case category.EdgeChildCategories:
		m.ResetChildCategories()
		return nil
	case category.EdgeParentCategory:
		m.ResetParentCategory()
		return nil
	case category.EdgeJobOfferCategories:
		m.ResetJobOfferCategories()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// ContactUsMessageMutation represents an operation that mutates the ContactUsMessage nodes in the graph.
type ContactUsMessageMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	email         *string
	message       *string
	phone         *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ContactUsMessage, error)
	predicates    []predicate.ContactUsMessage
}

var _ ent.Mutation = (*ContactUsMessageMutation)(nil)

// contactusmessageOption allows management of the mutation configuration using functional options.
type contactusmessageOption func(*ContactUsMessageMutation)

// newContactUsMessageMutation creates new mutation for the ContactUsMessage entity.
func newContactUsMessageMutation(c config, op Op, opts ...contactusmessageOption) *ContactUsMessageMutation {
	m := &ContactUsMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeContactUsMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactUsMessageID sets the ID field of the mutation.
func withContactUsMessageID(id uuid.UUID) contactusmessageOption {
	return func(m *ContactUsMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *ContactUsMessage
		)
		m.oldValue = func(ctx context.Context) (*ContactUsMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContactUsMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContactUsMessage sets the old ContactUsMessage of the mutation.
func withContactUsMessage(node *ContactUsMessage) contactusmessageOption {
	return func(m *ContactUsMessageMutation) {
		m.oldValue = func(context.Context) (*ContactUsMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactUsMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactUsMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ContactUsMessage entities.
func (m *ContactUsMessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactUsMessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactUsMessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContactUsMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ContactUsMessageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContactUsMessageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ContactUsMessage entity.
// If the ContactUsMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactUsMessageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ContactUsMessageMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *ContactUsMessageMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ContactUsMessageMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the ContactUsMessage entity.
// If the ContactUsMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactUsMessageMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *ContactUsMessageMutation) ResetEmail() {
	m.email = nil
}

// SetMessage sets the "message" field.
func (m *ContactUsMessageMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ContactUsMessageMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the ContactUsMessage entity.
// If the ContactUsMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactUsMessageMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *ContactUsMessageMutation) ResetMessage() {
	m.message = nil
}

// SetPhone sets the "phone" field.
func (m *ContactUsMessageMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ContactUsMessageMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the ContactUsMessage entity.
// If the ContactUsMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactUsMessageMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *ContactUsMessageMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[contactusmessage.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *ContactUsMessageMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[contactusmessage.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *ContactUsMessageMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, contactusmessage.FieldPhone)
}

// SetCreatedAt sets the "created_at" field.
func (m *ContactUsMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContactUsMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ContactUsMessage entity.
// If the ContactUsMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactUsMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ContactUsMessageMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[contactusmessage.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ContactUsMessageMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[contactusmessage.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContactUsMessageMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, contactusmessage.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContactUsMessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContactUsMessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ContactUsMessage entity.
// If the ContactUsMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactUsMessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ContactUsMessageMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[contactusmessage.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ContactUsMessageMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[contactusmessage.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContactUsMessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, contactusmessage.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ContactUsMessageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ContactUsMessageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ContactUsMessage entity.
// If the ContactUsMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactUsMessageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ContactUsMessageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[contactusmessage.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ContactUsMessageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[contactusmessage.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ContactUsMessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, contactusmessage.FieldDeletedAt)
}

// Where appends a list predicates to the ContactUsMessageMutation builder.
func (m *ContactUsMessageMutation) Where(ps ...predicate.ContactUsMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContactUsMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContactUsMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContactUsMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContactUsMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContactUsMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContactUsMessage).
func (m *ContactUsMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactUsMessageMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, contactusmessage.FieldName)
	}
	if m.email != nil {
		fields = append(fields, contactusmessage.FieldEmail)
	}
	if m.message != nil {
		fields = append(fields, contactusmessage.FieldMessage)
	}
	if m.phone != nil {
		fields = append(fields, contactusmessage.FieldPhone)
	}
	if m.created_at != nil {
		fields = append(fields, contactusmessage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contactusmessage.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, contactusmessage.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactUsMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contactusmessage.FieldName:
		return m.Name()
	case contactusmessage.FieldEmail:
		return m.Email()
	case contactusmessage.FieldMessage:
		return m.Message()
	case contactusmessage.FieldPhone:
		return m.Phone()
	case contactusmessage.FieldCreatedAt:
		return m.CreatedAt()
	case contactusmessage.FieldUpdatedAt:
		return m.UpdatedAt()
	case contactusmessage.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactUsMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contactusmessage.FieldName:
		return m.OldName(ctx)
	case contactusmessage.FieldEmail:
		return m.OldEmail(ctx)
	case contactusmessage.FieldMessage:
		return m.OldMessage(ctx)
	case contactusmessage.FieldPhone:
		return m.OldPhone(ctx)
	case contactusmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contactusmessage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contactusmessage.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ContactUsMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactUsMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contactusmessage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contactusmessage.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case contactusmessage.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case contactusmessage.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case contactusmessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contactusmessage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contactusmessage.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ContactUsMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactUsMessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactUsMessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactUsMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ContactUsMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactUsMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contactusmessage.FieldPhone) {
		fields = append(fields, contactusmessage.FieldPhone)
	}
	if m.FieldCleared(contactusmessage.FieldCreatedAt) {
		fields = append(fields, contactusmessage.FieldCreatedAt)
	}
	if m.FieldCleared(contactusmessage.FieldUpdatedAt) {
		fields = append(fields, contactusmessage.FieldUpdatedAt)
	}
	if m.FieldCleared(contactusmessage.FieldDeletedAt) {
		fields = append(fields, contactusmessage.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactUsMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactUsMessageMutation) ClearField(name string) error {
	switch name {
	case contactusmessage.FieldPhone:
		m.ClearPhone()
		return nil
	case contactusmessage.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case contactusmessage.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case contactusmessage.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ContactUsMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactUsMessageMutation) ResetField(name string) error {
	switch name {
	case contactusmessage.FieldName:
		m.ResetName()
		return nil
	case contactusmessage.FieldEmail:
		m.ResetEmail()
		return nil
	case contactusmessage.FieldMessage:
		m.ResetMessage()
		return nil
	case contactusmessage.FieldPhone:
		m.ResetPhone()
		return nil
	case contactusmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contactusmessage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contactusmessage.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ContactUsMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactUsMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactUsMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactUsMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactUsMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactUsMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactUsMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactUsMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ContactUsMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactUsMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ContactUsMessage edge %s", name)
}

// DegreeLevelMutation represents an operation that mutates the DegreeLevel nodes in the graph.
type DegreeLevelMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	educations        map[uuid.UUID]struct{}
	removededucations map[uuid.UUID]struct{}
	clearededucations bool
	done              bool
	oldValue          func(context.Context) (*DegreeLevel, error)
	predicates        []predicate.DegreeLevel
}

var _ ent.Mutation = (*DegreeLevelMutation)(nil)

// degreelevelOption allows management of the mutation configuration using functional options.
type degreelevelOption func(*DegreeLevelMutation)

// newDegreeLevelMutation creates new mutation for the DegreeLevel entity.
func newDegreeLevelMutation(c config, op Op, opts ...degreelevelOption) *DegreeLevelMutation {
	m := &DegreeLevelMutation{
		config:        c,
		op:            op,
		typ:           TypeDegreeLevel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDegreeLevelID sets the ID field of the mutation.
func withDegreeLevelID(id uuid.UUID) degreelevelOption {
	return func(m *DegreeLevelMutation) {
		var (
			err   error
			once  sync.Once
			value *DegreeLevel
		)
		m.oldValue = func(ctx context.Context) (*DegreeLevel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DegreeLevel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDegreeLevel sets the old DegreeLevel of the mutation.
func withDegreeLevel(node *DegreeLevel) degreelevelOption {
	return func(m *DegreeLevelMutation) {
		m.oldValue = func(context.Context) (*DegreeLevel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DegreeLevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DegreeLevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DegreeLevel entities.
func (m *DegreeLevelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DegreeLevelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DegreeLevelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DegreeLevel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DegreeLevelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DegreeLevelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DegreeLevel entity.
// If the DegreeLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DegreeLevelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DegreeLevelMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DegreeLevelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DegreeLevelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DegreeLevel entity.
// If the DegreeLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DegreeLevelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DegreeLevelMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[degreelevel.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DegreeLevelMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[degreelevel.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DegreeLevelMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, degreelevel.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DegreeLevelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DegreeLevelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DegreeLevel entity.
// If the DegreeLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DegreeLevelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DegreeLevelMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[degreelevel.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DegreeLevelMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[degreelevel.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DegreeLevelMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, degreelevel.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DegreeLevelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DegreeLevelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DegreeLevel entity.
// If the DegreeLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DegreeLevelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DegreeLevelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[degreelevel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DegreeLevelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[degreelevel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DegreeLevelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, degreelevel.FieldDeletedAt)
}

// AddEducationIDs adds the "educations" edge to the Education entity by ids.
func (m *DegreeLevelMutation) AddEducationIDs(ids ...uuid.UUID) {
	if m.educations == nil {
		m.educations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.educations[ids[i]] = struct{}{}
	}
}

// ClearEducations clears the "educations" edge to the Education entity.
func (m *DegreeLevelMutation) ClearEducations() {
	m.clearededucations = true
}

// EducationsCleared reports if the "educations" edge to the Education entity was cleared.
func (m *DegreeLevelMutation) EducationsCleared() bool {
	return m.clearededucations
}

// RemoveEducationIDs removes the "educations" edge to the Education entity by IDs.
func (m *DegreeLevelMutation) RemoveEducationIDs(ids ...uuid.UUID) {
	if m.removededucations == nil {
		m.removededucations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.educations, ids[i])
		m.removededucations[ids[i]] = struct{}{}
	}
}

// RemovedEducations returns the removed IDs of the "educations" edge to the Education entity.
func (m *DegreeLevelMutation) RemovedEducationsIDs() (ids []uuid.UUID) {
	for id := range m.removededucations {
		ids = append(ids, id)
	}
	return
}

// EducationsIDs returns the "educations" edge IDs in the mutation.
func (m *DegreeLevelMutation) EducationsIDs() (ids []uuid.UUID) {
	for id := range m.educations {
		ids = append(ids, id)
	}
	return
}

// ResetEducations resets all changes to the "educations" edge.
func (m *DegreeLevelMutation) ResetEducations() {
	m.educations = nil
	m.clearededucations = false
	m.removededucations = nil
}

// Where appends a list predicates to the DegreeLevelMutation builder.
func (m *DegreeLevelMutation) Where(ps ...predicate.DegreeLevel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DegreeLevelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DegreeLevelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DegreeLevel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DegreeLevelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DegreeLevelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DegreeLevel).
func (m *DegreeLevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DegreeLevelMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, degreelevel.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, degreelevel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, degreelevel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, degreelevel.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DegreeLevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case degreelevel.FieldName:
		return m.Name()
	case degreelevel.FieldCreatedAt:
		return m.CreatedAt()
	case degreelevel.FieldUpdatedAt:
		return m.UpdatedAt()
	case degreelevel.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DegreeLevelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case degreelevel.FieldName:
		return m.OldName(ctx)
	case degreelevel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case degreelevel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case degreelevel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DegreeLevel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DegreeLevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case degreelevel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case degreelevel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case degreelevel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case degreelevel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DegreeLevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DegreeLevelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DegreeLevelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DegreeLevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DegreeLevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DegreeLevelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(degreelevel.FieldCreatedAt) {
		fields = append(fields, degreelevel.FieldCreatedAt)
	}
	if m.FieldCleared(degreelevel.FieldUpdatedAt) {
		fields = append(fields, degreelevel.FieldUpdatedAt)
	}
	if m.FieldCleared(degreelevel.FieldDeletedAt) {
		fields = append(fields, degreelevel.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DegreeLevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DegreeLevelMutation) ClearField(name string) error {
	switch name {
	case degreelevel.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case degreelevel.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case degreelevel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DegreeLevel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DegreeLevelMutation) ResetField(name string) error {
	switch name {
	case degreelevel.FieldName:
		m.ResetName()
		return nil
	case degreelevel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case degreelevel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case degreelevel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DegreeLevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DegreeLevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.educations != nil {
		edges = append(edges, degreelevel.EdgeEducations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DegreeLevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case degreelevel.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.educations))
		for id := range m.educations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DegreeLevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removededucations != nil {
		edges = append(edges, degreelevel.EdgeEducations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DegreeLevelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case degreelevel.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.removededucations))
		for id := range m.removededucations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DegreeLevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearededucations {
		edges = append(edges, degreelevel.EdgeEducations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DegreeLevelMutation) EdgeCleared(name string) bool {
	switch name {
	case degreelevel.EdgeEducations:
		return m.clearededucations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DegreeLevelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DegreeLevel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DegreeLevelMutation) ResetEdge(name string) error {
	switch name {
	case degreelevel.EdgeEducations:
		m.ResetEducations()
		return nil
	}
	return fmt.Errorf("unknown DegreeLevel edge %s", name)
}

// EducationMutation represents an operation that mutates the Education nodes in the graph.
type EducationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	title                *string
	institution          *string
	date_obtained        *time.Time
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	comments             *string
	applicant_profile_id *uuid.UUID
	clearedFields        map[string]struct{}
	degree_level         *uuid.UUID
	cleareddegree_level  bool
	done                 bool
	oldValue             func(context.Context) (*Education, error)
	predicates           []predicate.Education
}

var _ ent.Mutation = (*EducationMutation)(nil)

// educationOption allows management of the mutation configuration using functional options.
type educationOption func(*EducationMutation)

// newEducationMutation creates new mutation for the Education entity.
func newEducationMutation(c config, op Op, opts ...educationOption) *EducationMutation {
	m := &EducationMutation{
		config:        c,
		op:            op,
		typ:           TypeEducation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationID sets the ID field of the mutation.
func withEducationID(id uuid.UUID) educationOption {
	return func(m *EducationMutation) {
		var (
			err   error
			once  sync.Once
			value *Education
		)
		m.oldValue = func(ctx context.Context) (*Education, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Education.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducation sets the old Education of the mutation.
func withEducation(node *Education) educationOption {
	return func(m *EducationMutation) {
		m.oldValue = func(context.Context) (*Education, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Education entities.
func (m *EducationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EducationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EducationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Education.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *EducationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EducationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EducationMutation) ResetTitle() {
	m.title = nil
}

// SetInstitution sets the "institution" field.
func (m *EducationMutation) SetInstitution(s string) {
	m.institution = &s
}

// Institution returns the value of the "institution" field in the mutation.
func (m *EducationMutation) Institution() (r string, exists bool) {
	v := m.institution
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitution returns the old "institution" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldInstitution(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitution: %w", err)
	}
	return oldValue.Institution, nil
}

// ClearInstitution clears the value of the "institution" field.
func (m *EducationMutation) ClearInstitution() {
	m.institution = nil
	m.clearedFields[education.FieldInstitution] = struct{}{}
}

// InstitutionCleared returns if the "institution" field was cleared in this mutation.
func (m *EducationMutation) InstitutionCleared() bool {
	_, ok := m.clearedFields[education.FieldInstitution]
	return ok
}

// ResetInstitution resets all changes to the "institution" field.
func (m *EducationMutation) ResetInstitution() {
	m.institution = nil
	delete(m.clearedFields, education.FieldInstitution)
}

// SetDateObtained sets the "date_obtained" field.
func (m *EducationMutation) SetDateObtained(t time.Time) {
	m.date_obtained = &t
}

// DateObtained returns the value of the "date_obtained" field in the mutation.
func (m *EducationMutation) DateObtained() (r time.Time, exists bool) {
	v := m.date_obtained
	if v == nil {
		return
	}
	return *v, true
}

// OldDateObtained returns the old "date_obtained" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldDateObtained(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateObtained is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateObtained requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateObtained: %w", err)
	}
	return oldValue.DateObtained, nil
}

// ClearDateObtained clears the value of the "date_obtained" field.
func (m *EducationMutation) ClearDateObtained() {
	m.date_obtained = nil
	m.clearedFields[education.FieldDateObtained] = struct{}{}
}

// DateObtainedCleared returns if the "date_obtained" field was cleared in this mutation.
func (m *EducationMutation) DateObtainedCleared() bool {
	_, ok := m.clearedFields[education.FieldDateObtained]
	return ok
}

// ResetDateObtained resets all changes to the "date_obtained" field.
func (m *EducationMutation) ResetDateObtained() {
	m.date_obtained = nil
	delete(m.clearedFields, education.FieldDateObtained)
}

// SetDegreeLevelID sets the "degree_level_id" field.
func (m *EducationMutation) SetDegreeLevelID(u uuid.UUID) {
	m.degree_level = &u
}

// DegreeLevelID returns the value of the "degree_level_id" field in the mutation.
func (m *EducationMutation) DegreeLevelID() (r uuid.UUID, exists bool) {
	v := m.degree_level
	if v == nil {
		return
	}
	return *v, true
}

// OldDegreeLevelID returns the old "degree_level_id" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldDegreeLevelID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDegreeLevelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDegreeLevelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegreeLevelID: %w", err)
	}
	return oldValue.DegreeLevelID, nil
}

// ClearDegreeLevelID clears the value of the "degree_level_id" field.
func (m *EducationMutation) ClearDegreeLevelID() {
	m.degree_level = nil
	m.clearedFields[education.FieldDegreeLevelID] = struct{}{}
}

// DegreeLevelIDCleared returns if the "degree_level_id" field was cleared in this mutation.
func (m *EducationMutation) DegreeLevelIDCleared() bool {
	_, ok := m.clearedFields[education.FieldDegreeLevelID]
	return ok
}

// ResetDegreeLevelID resets all changes to the "degree_level_id" field.
func (m *EducationMutation) ResetDegreeLevelID() {
	m.degree_level = nil
	delete(m.clearedFields, education.FieldDegreeLevelID)
}

// SetCreatedAt sets the "created_at" field.
func (m *EducationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EducationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EducationMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[education.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EducationMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[education.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EducationMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, education.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EducationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EducationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EducationMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[education.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EducationMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[education.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EducationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, education.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EducationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EducationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EducationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[education.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EducationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[education.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EducationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, education.FieldDeletedAt)
}

// SetComments sets the "comments" field.
func (m *EducationMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *EducationMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *EducationMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[education.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *EducationMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[education.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *EducationMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, education.FieldComments)
}

// SetApplicantProfileID sets the "applicant_profile_id" field.
func (m *EducationMutation) SetApplicantProfileID(u uuid.UUID) {
	m.applicant_profile_id = &u
}

// ApplicantProfileID returns the value of the "applicant_profile_id" field in the mutation.
func (m *EducationMutation) ApplicantProfileID() (r uuid.UUID, exists bool) {
	v := m.applicant_profile_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicantProfileID returns the old "applicant_profile_id" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldApplicantProfileID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicantProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicantProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicantProfileID: %w", err)
	}
	return oldValue.ApplicantProfileID, nil
}

// ClearApplicantProfileID clears the value of the "applicant_profile_id" field.
func (m *EducationMutation) ClearApplicantProfileID() {
	m.applicant_profile_id = nil
	m.clearedFields[education.FieldApplicantProfileID] = struct{}{}
}

// ApplicantProfileIDCleared returns if the "applicant_profile_id" field was cleared in this mutation.
func (m *EducationMutation) ApplicantProfileIDCleared() bool {
	_, ok := m.clearedFields[education.FieldApplicantProfileID]
	return ok
}

// ResetApplicantProfileID resets all changes to the "applicant_profile_id" field.
func (m *EducationMutation) ResetApplicantProfileID() {
	m.applicant_profile_id = nil
	delete(m.clearedFields, education.FieldApplicantProfileID)
}

// ClearDegreeLevel clears the "degree_level" edge to the DegreeLevel entity.
func (m *EducationMutation) ClearDegreeLevel() {
	m.cleareddegree_level = true
}

// DegreeLevelCleared reports if the "degree_level" edge to the DegreeLevel entity was cleared.
func (m *EducationMutation) DegreeLevelCleared() bool {
	return m.DegreeLevelIDCleared() || m.cleareddegree_level
}

// DegreeLevelIDs returns the "degree_level" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DegreeLevelID instead. It exists only for internal usage by the builders.
func (m *EducationMutation) DegreeLevelIDs() (ids []uuid.UUID) {
	if id := m.degree_level; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDegreeLevel resets all changes to the "degree_level" edge.
func (m *EducationMutation) ResetDegreeLevel() {
	m.degree_level = nil
	m.cleareddegree_level = false
}

// Where appends a list predicates to the EducationMutation builder.
func (m *EducationMutation) Where(ps ...predicate.Education) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EducationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EducationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Education, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EducationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EducationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Education).
func (m *EducationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EducationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.title != nil {
		fields = append(fields, education.FieldTitle)
	}
	if m.institution != nil {
		fields = append(fields, education.FieldInstitution)
	}
	if m.date_obtained != nil {
		fields = append(fields, education.FieldDateObtained)
	}
	if m.degree_level != nil {
		fields = append(fields, education.FieldDegreeLevelID)
	}
	if m.created_at != nil {
		fields = append(fields, education.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, education.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, education.FieldDeletedAt)
	}
	if m.comments != nil {
		fields = append(fields, education.FieldComments)
	}
	if m.applicant_profile_id != nil {
		fields = append(fields, education.FieldApplicantProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EducationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case education.FieldTitle:
		return m.Title()
	case education.FieldInstitution:
		return m.Institution()
	case education.FieldDateObtained:
		return m.DateObtained()
	case education.FieldDegreeLevelID:
		return m.DegreeLevelID()
	case education.FieldCreatedAt:
		return m.CreatedAt()
	case education.FieldUpdatedAt:
		return m.UpdatedAt()
	case education.FieldDeletedAt:
		return m.DeletedAt()
	case education.FieldComments:
		return m.Comments()
	case education.FieldApplicantProfileID:
		return m.ApplicantProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EducationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case education.FieldTitle:
		return m.OldTitle(ctx)
	case education.FieldInstitution:
		return m.OldInstitution(ctx)
	case education.FieldDateObtained:
		return m.OldDateObtained(ctx)
	case education.FieldDegreeLevelID:
		return m.OldDegreeLevelID(ctx)
	case education.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case education.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case education.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case education.FieldComments:
		return m.OldComments(ctx)
	case education.FieldApplicantProfileID:
		return m.OldApplicantProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown Education field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case education.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case education.FieldInstitution:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitution(v)
		return nil
	case education.FieldDateObtained:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateObtained(v)
		return nil
	case education.FieldDegreeLevelID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegreeLevelID(v)
		return nil
	case education.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case education.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case education.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case education.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case education.FieldApplicantProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicantProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EducationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EducationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Education numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EducationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(education.FieldInstitution) {
		fields = append(fields, education.FieldInstitution)
	}
	if m.FieldCleared(education.FieldDateObtained) {
		fields = append(fields, education.FieldDateObtained)
	}
	if m.FieldCleared(education.FieldDegreeLevelID) {
		fields = append(fields, education.FieldDegreeLevelID)
	}
	if m.FieldCleared(education.FieldCreatedAt) {
		fields = append(fields, education.FieldCreatedAt)
	}
	if m.FieldCleared(education.FieldUpdatedAt) {
		fields = append(fields, education.FieldUpdatedAt)
	}
	if m.FieldCleared(education.FieldDeletedAt) {
		fields = append(fields, education.FieldDeletedAt)
	}
	if m.FieldCleared(education.FieldComments) {
		fields = append(fields, education.FieldComments)
	}
	if m.FieldCleared(education.FieldApplicantProfileID) {
		fields = append(fields, education.FieldApplicantProfileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EducationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationMutation) ClearField(name string) error {
	switch name {
	case education.FieldInstitution:
		m.ClearInstitution()
		return nil
	case education.FieldDateObtained:
		m.ClearDateObtained()
		return nil
	case education.FieldDegreeLevelID:
		m.ClearDegreeLevelID()
		return nil
	case education.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case education.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case education.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case education.FieldComments:
		m.ClearComments()
		return nil
	case education.FieldApplicantProfileID:
		m.ClearApplicantProfileID()
		return nil
	}
	return fmt.Errorf("unknown Education nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EducationMutation) ResetField(name string) error {
	switch name {
	case education.FieldTitle:
		m.ResetTitle()
		return nil
	case education.FieldInstitution:
		m.ResetInstitution()
		return nil
	case education.FieldDateObtained:
		m.ResetDateObtained()
		return nil
	case education.FieldDegreeLevelID:
		m.ResetDegreeLevelID()
		return nil
	case education.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case education.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case education.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case education.FieldComments:
		m.ResetComments()
		return nil
	case education.FieldApplicantProfileID:
		m.ResetApplicantProfileID()
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EducationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.degree_level != nil {
		edges = append(edges, education.EdgeDegreeLevel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EducationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case education.EdgeDegreeLevel:
		if id := m.degree_level; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EducationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EducationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EducationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddegree_level {
		edges = append(edges, education.EdgeDegreeLevel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EducationMutation) EdgeCleared(name string) bool {
	switch name {
	case education.EdgeDegreeLevel:
		return m.cleareddegree_level
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EducationMutation) ClearEdge(name string) error {
	switch name {
	case education.EdgeDegreeLevel:
		m.ClearDegreeLevel()
		return nil
	}
	return fmt.Errorf("unknown Education unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EducationMutation) ResetEdge(name string) error {
	switch name {
	case education.EdgeDegreeLevel:
		m.ResetDegreeLevel()
		return nil
	}
	return fmt.Errorf("unknown Education edge %s", name)
}

// InterviewMutation represents an operation that mutates the Interview nodes in the graph.
type InterviewMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	comment            *string
	interview_date     *time.Time
	status             *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	clearedFields      map[string]struct{}
	application        *uuid.UUID
	clearedapplication bool
	user               *uuid.UUID
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*Interview, error)
	predicates         []predicate.Interview
}

var _ ent.Mutation = (*InterviewMutation)(nil)

// interviewOption allows management of the mutation configuration using functional options.
type interviewOption func(*InterviewMutation)

// newInterviewMutation creates new mutation for the Interview entity.
func newInterviewMutation(c config, op Op, opts ...interviewOption) *InterviewMutation {
	m := &InterviewMutation{
		config:        c,
		op:            op,
		typ:           TypeInterview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInterviewID sets the ID field of the mutation.
func withInterviewID(id uuid.UUID) interviewOption {
	return func(m *InterviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Interview
		)
		m.oldValue = func(ctx context.Context) (*Interview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Interview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInterview sets the old Interview of the mutation.
func withInterview(node *Interview) interviewOption {
	return func(m *InterviewMutation) {
		m.oldValue = func(context.Context) (*Interview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InterviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InterviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Interview entities.
func (m *InterviewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InterviewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InterviewMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Interview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetComment sets the "comment" field.
func (m *InterviewMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *InterviewMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *InterviewMutation) ResetComment() {
	m.comment = nil
}

// SetInterviewDate sets the "interview_date" field.
func (m *InterviewMutation) SetInterviewDate(t time.Time) {
	m.interview_date = &t
}

// InterviewDate returns the value of the "interview_date" field in the mutation.
func (m *InterviewMutation) InterviewDate() (r time.Time, exists bool) {
	v := m.interview_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInterviewDate returns the old "interview_date" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldInterviewDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterviewDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterviewDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterviewDate: %w", err)
	}
	return oldValue.InterviewDate, nil
}

// ResetInterviewDate resets all changes to the "interview_date" field.
func (m *InterviewMutation) ResetInterviewDate() {
	m.interview_date = nil
}

// SetStatus sets the "status" field.
func (m *InterviewMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *InterviewMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InterviewMutation) ResetStatus() {
	m.status = nil
}

// SetApplicationID sets the "application_id" field.
func (m *InterviewMutation) SetApplicationID(u uuid.UUID) {
	m.application = &u
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *InterviewMutation) ApplicationID() (r uuid.UUID, exists bool) {
	v := m.application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldApplicationID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ClearApplicationID clears the value of the "application_id" field.
func (m *InterviewMutation) ClearApplicationID() {
	m.application = nil
	m.clearedFields[interview.FieldApplicationID] = struct{}{}
}

// ApplicationIDCleared returns if the "application_id" field was cleared in this mutation.
func (m *InterviewMutation) ApplicationIDCleared() bool {
	_, ok := m.clearedFields[interview.FieldApplicationID]
	return ok
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *InterviewMutation) ResetApplicationID() {
	m.application = nil
	delete(m.clearedFields, interview.FieldApplicationID)
}

// SetInterviewerID sets the "interviewer_id" field.
func (m *InterviewMutation) SetInterviewerID(u uuid.UUID) {
	m.user = &u
}

// InterviewerID returns the value of the "interviewer_id" field in the mutation.
func (m *InterviewMutation) InterviewerID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldInterviewerID returns the old "interviewer_id" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldInterviewerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterviewerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterviewerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterviewerID: %w", err)
	}
	return oldValue.InterviewerID, nil
}

// ClearInterviewerID clears the value of the "interviewer_id" field.
func (m *InterviewMutation) ClearInterviewerID() {
	m.user = nil
	m.clearedFields[interview.FieldInterviewerID] = struct{}{}
}

// InterviewerIDCleared returns if the "interviewer_id" field was cleared in this mutation.
func (m *InterviewMutation) InterviewerIDCleared() bool {
	_, ok := m.clearedFields[interview.FieldInterviewerID]
	return ok
}

// ResetInterviewerID resets all changes to the "interviewer_id" field.
func (m *InterviewMutation) ResetInterviewerID() {
	m.user = nil
	delete(m.clearedFields, interview.FieldInterviewerID)
}

// SetCreatedAt sets the "created_at" field.
func (m *InterviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InterviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InterviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InterviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InterviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InterviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InterviewMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InterviewMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InterviewMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[interview.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InterviewMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[interview.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InterviewMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, interview.FieldDeletedAt)
}

// ClearApplication clears the "application" edge to the Application entity.
func (m *InterviewMutation) ClearApplication() {
	m.clearedapplication = true
}

// ApplicationCleared reports if the "application" edge to the Application entity was cleared.
func (m *InterviewMutation) ApplicationCleared() bool {
	return m.ApplicationIDCleared() || m.clearedapplication
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *InterviewMutation) ApplicationIDs() (ids []uuid.UUID) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *InterviewMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *InterviewMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *InterviewMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InterviewMutation) UserCleared() bool {
	return m.InterviewerIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *InterviewMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InterviewMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InterviewMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the InterviewMutation builder.
func (m *InterviewMutation) Where(ps ...predicate.Interview) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InterviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InterviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Interview, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InterviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InterviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Interview).
func (m *InterviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InterviewMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.comment != nil {
		fields = append(fields, interview.FieldComment)
	}
	if m.interview_date != nil {
		fields = append(fields, interview.FieldInterviewDate)
	}
	if m.status != nil {
		fields = append(fields, interview.FieldStatus)
	}
	if m.application != nil {
		fields = append(fields, interview.FieldApplicationID)
	}
	if m.user != nil {
		fields = append(fields, interview.FieldInterviewerID)
	}
	if m.created_at != nil {
		fields = append(fields, interview.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, interview.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, interview.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InterviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case interview.FieldComment:
		return m.Comment()
	case interview.FieldInterviewDate:
		return m.InterviewDate()
	case interview.FieldStatus:
		return m.Status()
	case interview.FieldApplicationID:
		return m.ApplicationID()
	case interview.FieldInterviewerID:
		return m.InterviewerID()
	case interview.FieldCreatedAt:
		return m.CreatedAt()
	case interview.FieldUpdatedAt:
		return m.UpdatedAt()
	case interview.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InterviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case interview.FieldComment:
		return m.OldComment(ctx)
	case interview.FieldInterviewDate:
		return m.OldInterviewDate(ctx)
	case interview.FieldStatus:
		return m.OldStatus(ctx)
	case interview.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case interview.FieldInterviewerID:
		return m.OldInterviewerID(ctx)
	case interview.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case interview.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case interview.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Interview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case interview.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case interview.FieldInterviewDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterviewDate(v)
		return nil
	case interview.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case interview.FieldApplicationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case interview.FieldInterviewerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterviewerID(v)
		return nil
	case interview.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case interview.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case interview.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Interview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InterviewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InterviewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Interview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InterviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(interview.FieldApplicationID) {
		fields = append(fields, interview.FieldApplicationID)
	}
	if m.FieldCleared(interview.FieldInterviewerID) {
		fields = append(fields, interview.FieldInterviewerID)
	}
	if m.FieldCleared(interview.FieldDeletedAt) {
		fields = append(fields, interview.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InterviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InterviewMutation) ClearField(name string) error {
	switch name {
	case interview.FieldApplicationID:
		m.ClearApplicationID()
		return nil
	case interview.FieldInterviewerID:
		m.ClearInterviewerID()
		return nil
	case interview.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Interview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InterviewMutation) ResetField(name string) error {
	switch name {
	case interview.FieldComment:
		m.ResetComment()
		return nil
	case interview.FieldInterviewDate:
		m.ResetInterviewDate()
		return nil
	case interview.FieldStatus:
		m.ResetStatus()
		return nil
	case interview.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case interview.FieldInterviewerID:
		m.ResetInterviewerID()
		return nil
	case interview.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case interview.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case interview.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Interview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InterviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.application != nil {
		edges = append(edges, interview.EdgeApplication)
	}
	if m.user != nil {
		edges = append(edges, interview.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InterviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case interview.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	case interview.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InterviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InterviewMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InterviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapplication {
		edges = append(edges, interview.EdgeApplication)
	}
	if m.cleareduser {
		edges = append(edges, interview.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InterviewMutation) EdgeCleared(name string) bool {
	switch name {
	case interview.EdgeApplication:
		return m.clearedapplication
	case interview.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InterviewMutation) ClearEdge(name string) error {
	switch name {
	case interview.EdgeApplication:
		m.ClearApplication()
		return nil
	case interview.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Interview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InterviewMutation) ResetEdge(name string) error {
	switch name {
	case interview.EdgeApplication:
		m.ResetApplication()
		return nil
	case interview.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Interview edge %s", name)
}

// JobOfferMutation represents an operation that mutates the JobOffer nodes in the graph.
type JobOfferMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	title                       *string
	reference                   *int32
	addreference                *int32
	start_date                  *time.Time
	end_date                    *time.Time
	address1                    *string
	address2                    *string
	department                  *string
	description                 *string
	working_hours               *string
	salary                      *string
	slug                        *string
	is_featured                 *bool
	has_been_emailed            *bool
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	clearedFields               map[string]struct{}
	applications                map[uuid.UUID]struct{}
	removedapplications         map[uuid.UUID]struct{}
	clearedapplications         bool
	job_offer_categories        map[uuid.UUID]struct{}
	removedjob_offer_categories map[uuid.UUID]struct{}
	clearedjob_offer_categories bool
	status                      *uuid.UUID
	clearedstatus               bool
	done                        bool
	oldValue                    func(context.Context) (*JobOffer, error)
	predicates                  []predicate.JobOffer
}

var _ ent.Mutation = (*JobOfferMutation)(nil)

// jobofferOption allows management of the mutation configuration using functional options.
type jobofferOption func(*JobOfferMutation)

// newJobOfferMutation creates new mutation for the JobOffer entity.
func newJobOfferMutation(c config, op Op, opts ...jobofferOption) *JobOfferMutation {
	m := &JobOfferMutation{
		config:        c,
		op:            op,
		typ:           TypeJobOffer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobOfferID sets the ID field of the mutation.
func withJobOfferID(id uuid.UUID) jobofferOption {
	return func(m *JobOfferMutation) {
		var (
			err   error
			once  sync.Once
			value *JobOffer
		)
		m.oldValue = func(ctx context.Context) (*JobOffer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobOffer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobOffer sets the old JobOffer of the mutation.
func withJobOffer(node *JobOffer) jobofferOption {
	return func(m *JobOfferMutation) {
		m.oldValue = func(context.Context) (*JobOffer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobOfferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobOfferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobOffer entities.
func (m *JobOfferMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobOfferMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobOfferMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobOffer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *JobOfferMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *JobOfferMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *JobOfferMutation) ResetTitle() {
	m.title = nil
}

// SetReference sets the "reference" field.
func (m *JobOfferMutation) SetReference(i int32) {
	m.reference = &i
	m.addreference = nil
}

// Reference returns the value of the "reference" field in the mutation.
func (m *JobOfferMutation) Reference() (r int32, exists bool) {
	v := m.reference
	if v == nil {
		return
	}
	return *v, true
}

// OldReference returns the old "reference" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldReference(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReference: %w", err)
	}
	return oldValue.Reference, nil
}

// AddReference adds i to the "reference" field.
func (m *JobOfferMutation) AddReference(i int32) {
	if m.addreference != nil {
		*m.addreference += i
	} else {
		m.addreference = &i
	}
}

// AddedReference returns the value that was added to the "reference" field in this mutation.
func (m *JobOfferMutation) AddedReference() (r int32, exists bool) {
	v := m.addreference
	if v == nil {
		return
	}
	return *v, true
}

// ResetReference resets all changes to the "reference" field.
func (m *JobOfferMutation) ResetReference() {
	m.reference = nil
	m.addreference = nil
}

// SetStartDate sets the "start_date" field.
func (m *JobOfferMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *JobOfferMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *JobOfferMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *JobOfferMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *JobOfferMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *JobOfferMutation) ResetEndDate() {
	m.end_date = nil
}

// SetAddress1 sets the "address1" field.
func (m *JobOfferMutation) SetAddress1(s string) {
	m.address1 = &s
}

// Address1 returns the value of the "address1" field in the mutation.
func (m *JobOfferMutation) Address1() (r string, exists bool) {
	v := m.address1
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress1 returns the old "address1" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldAddress1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress1: %w", err)
	}
	return oldValue.Address1, nil
}

// ClearAddress1 clears the value of the "address1" field.
func (m *JobOfferMutation) ClearAddress1() {
	m.address1 = nil
	m.clearedFields[joboffer.FieldAddress1] = struct{}{}
}

// Address1Cleared returns if the "address1" field was cleared in this mutation.
func (m *JobOfferMutation) Address1Cleared() bool {
	_, ok := m.clearedFields[joboffer.FieldAddress1]
	return ok
}

// ResetAddress1 resets all changes to the "address1" field.
func (m *JobOfferMutation) ResetAddress1() {
	m.address1 = nil
	delete(m.clearedFields, joboffer.FieldAddress1)
}

// SetAddress2 sets the "address2" field.
func (m *JobOfferMutation) SetAddress2(s string) {
	m.address2 = &s
}

// Address2 returns the value of the "address2" field in the mutation.
func (m *JobOfferMutation) Address2() (r string, exists bool) {
	v := m.address2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress2 returns the old "address2" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldAddress2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress2: %w", err)
	}
	return oldValue.Address2, nil
}

// ClearAddress2 clears the value of the "address2" field.
func (m *JobOfferMutation) ClearAddress2() {
	m.address2 = nil
	m.clearedFields[joboffer.FieldAddress2] = struct{}{}
}

// Address2Cleared returns if the "address2" field was cleared in this mutation.
func (m *JobOfferMutation) Address2Cleared() bool {
	_, ok := m.clearedFields[joboffer.FieldAddress2]
	return ok
}

// ResetAddress2 resets all changes to the "address2" field.
func (m *JobOfferMutation) ResetAddress2() {
	m.address2 = nil
	delete(m.clearedFields, joboffer.FieldAddress2)
}

// SetDepartment sets the "department" field.
func (m *JobOfferMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *JobOfferMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ResetDepartment resets all changes to the "department" field.
func (m *JobOfferMutation) ResetDepartment() {
	m.department = nil
}

// SetDescription sets the "description" field.
func (m *JobOfferMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *JobOfferMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *JobOfferMutation) ResetDescription() {
	m.description = nil
}

// SetWorkingHours sets the "working_hours" field.
func (m *JobOfferMutation) SetWorkingHours(s string) {
	m.working_hours = &s
}

// WorkingHours returns the value of the "working_hours" field in the mutation.
func (m *JobOfferMutation) WorkingHours() (r string, exists bool) {
	v := m.working_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkingHours returns the old "working_hours" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldWorkingHours(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkingHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkingHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkingHours: %w", err)
	}
	return oldValue.WorkingHours, nil
}

// ResetWorkingHours resets all changes to the "working_hours" field.
func (m *JobOfferMutation) ResetWorkingHours() {
	m.working_hours = nil
}

// SetSalary sets the "salary" field.
func (m *JobOfferMutation) SetSalary(s string) {
	m.salary = &s
}

// Salary returns the value of the "salary" field in the mutation.
func (m *JobOfferMutation) Salary() (r string, exists bool) {
	v := m.salary
	if v == nil {
		return
	}
	return *v, true
}

// OldSalary returns the old "salary" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldSalary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalary: %w", err)
	}
	return oldValue.Salary, nil
}

// ResetSalary resets all changes to the "salary" field.
func (m *JobOfferMutation) ResetSalary() {
	m.salary = nil
}

// SetSlug sets the "slug" field.
func (m *JobOfferMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *JobOfferMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *JobOfferMutation) ResetSlug() {
	m.slug = nil
}

// SetIsFeatured sets the "is_featured" field.
func (m *JobOfferMutation) SetIsFeatured(b bool) {
	m.is_featured = &b
}

// IsFeatured returns the value of the "is_featured" field in the mutation.
func (m *JobOfferMutation) IsFeatured() (r bool, exists bool) {
	v := m.is_featured
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFeatured returns the old "is_featured" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldIsFeatured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFeatured: %w", err)
	}
	return oldValue.IsFeatured, nil
}

// ClearIsFeatured clears the value of the "is_featured" field.
func (m *JobOfferMutation) ClearIsFeatured() {
	m.is_featured = nil
	m.clearedFields[joboffer.FieldIsFeatured] = struct{}{}
}

// IsFeaturedCleared returns if the "is_featured" field was cleared in this mutation.
func (m *JobOfferMutation) IsFeaturedCleared() bool {
	_, ok := m.clearedFields[joboffer.FieldIsFeatured]
	return ok
}

// ResetIsFeatured resets all changes to the "is_featured" field.
func (m *JobOfferMutation) ResetIsFeatured() {
	m.is_featured = nil
	delete(m.clearedFields, joboffer.FieldIsFeatured)
}

// SetHasBeenEmailed sets the "has_been_emailed" field.
func (m *JobOfferMutation) SetHasBeenEmailed(b bool) {
	m.has_been_emailed = &b
}

// HasBeenEmailed returns the value of the "has_been_emailed" field in the mutation.
func (m *JobOfferMutation) HasBeenEmailed() (r bool, exists bool) {
	v := m.has_been_emailed
	if v == nil {
		return
	}
	return *v, true
}

// OldHasBeenEmailed returns the old "has_been_emailed" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldHasBeenEmailed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasBeenEmailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasBeenEmailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasBeenEmailed: %w", err)
	}
	return oldValue.HasBeenEmailed, nil
}

// ClearHasBeenEmailed clears the value of the "has_been_emailed" field.
func (m *JobOfferMutation) ClearHasBeenEmailed() {
	m.has_been_emailed = nil
	m.clearedFields[joboffer.FieldHasBeenEmailed] = struct{}{}
}

// HasBeenEmailedCleared returns if the "has_been_emailed" field was cleared in this mutation.
func (m *JobOfferMutation) HasBeenEmailedCleared() bool {
	_, ok := m.clearedFields[joboffer.FieldHasBeenEmailed]
	return ok
}

// ResetHasBeenEmailed resets all changes to the "has_been_emailed" field.
func (m *JobOfferMutation) ResetHasBeenEmailed() {
	m.has_been_emailed = nil
	delete(m.clearedFields, joboffer.FieldHasBeenEmailed)
}

// SetStatusID sets the "status_id" field.
func (m *JobOfferMutation) SetStatusID(u uuid.UUID) {
	m.status = &u
}

// StatusID returns the value of the "status_id" field in the mutation.
func (m *JobOfferMutation) StatusID() (r uuid.UUID, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusID returns the old "status_id" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldStatusID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusID: %w", err)
	}
	return oldValue.StatusID, nil
}

// ClearStatusID clears the value of the "status_id" field.
func (m *JobOfferMutation) ClearStatusID() {
	m.status = nil
	m.clearedFields[joboffer.FieldStatusID] = struct{}{}
}

// StatusIDCleared returns if the "status_id" field was cleared in this mutation.
func (m *JobOfferMutation) StatusIDCleared() bool {
	_, ok := m.clearedFields[joboffer.FieldStatusID]
	return ok
}

// ResetStatusID resets all changes to the "status_id" field.
func (m *JobOfferMutation) ResetStatusID() {
	m.status = nil
	delete(m.clearedFields, joboffer.FieldStatusID)
}

// SetCreatedAt sets the "created_at" field.
func (m *JobOfferMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobOfferMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *JobOfferMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[joboffer.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *JobOfferMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[joboffer.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobOfferMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, joboffer.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobOfferMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobOfferMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *JobOfferMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[joboffer.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *JobOfferMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[joboffer.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobOfferMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, joboffer.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobOfferMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobOfferMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the JobOffer entity.
// If the JobOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobOfferMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[joboffer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobOfferMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[joboffer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobOfferMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, joboffer.FieldDeletedAt)
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *JobOfferMutation) AddApplicationIDs(ids ...uuid.UUID) {
	if m.applications == nil {
		m.applications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *JobOfferMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *JobOfferMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *JobOfferMutation) RemoveApplicationIDs(ids ...uuid.UUID) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *JobOfferMutation) RemovedApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *JobOfferMutation) ApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *JobOfferMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// AddJobOfferCategoryIDs adds the "job_offer_categories" edge to the JobOfferCategory entity by ids.
func (m *JobOfferMutation) AddJobOfferCategoryIDs(ids ...uuid.UUID) {
	if m.job_offer_categories == nil {
		m.job_offer_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.job_offer_categories[ids[i]] = struct{}{}
	}
}

// ClearJobOfferCategories clears the "job_offer_categories" edge to the JobOfferCategory entity.
func (m *JobOfferMutation) ClearJobOfferCategories() {
	m.clearedjob_offer_categories = true
}

// JobOfferCategoriesCleared reports if the "job_offer_categories" edge to the JobOfferCategory entity was cleared.
func (m *JobOfferMutation) JobOfferCategoriesCleared() bool {
	return m.clearedjob_offer_categories
}

// RemoveJobOfferCategoryIDs removes the "job_offer_categories" edge to the JobOfferCategory entity by IDs.
func (m *JobOfferMutation) RemoveJobOfferCategoryIDs(ids ...uuid.UUID) {
	if m.removedjob_offer_categories == nil {
		m.removedjob_offer_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.job_offer_categories, ids[i])
		m.removedjob_offer_categories[ids[i]] = struct{}{}
	}
}

// RemovedJobOfferCategories returns the removed IDs of the "job_offer_categories" edge to the JobOfferCategory entity.
func (m *JobOfferMutation) RemovedJobOfferCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedjob_offer_categories {
		ids = append(ids, id)
	}
	return
}

// JobOfferCategoriesIDs returns the "job_offer_categories" edge IDs in the mutation.
func (m *JobOfferMutation) JobOfferCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.job_offer_categories {
		ids = append(ids, id)
	}
	return
}

// ResetJobOfferCategories resets all changes to the "job_offer_categories" edge.
func (m *JobOfferMutation) ResetJobOfferCategories() {
	m.job_offer_categories = nil
	m.clearedjob_offer_categories = false
	m.removedjob_offer_categories = nil
}

// ClearStatus clears the "status" edge to the Status entity.
func (m *JobOfferMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared reports if the "status" edge to the Status entity was cleared.
func (m *JobOfferMutation) StatusCleared() bool {
	return m.StatusIDCleared() || m.clearedstatus
}

// StatusIDs returns the "status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *JobOfferMutation) StatusIDs() (ids []uuid.UUID) {
	if id := m.status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus resets all changes to the "status" edge.
func (m *JobOfferMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
}

// Where appends a list predicates to the JobOfferMutation builder.
func (m *JobOfferMutation) Where(ps ...predicate.JobOffer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobOfferMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobOfferMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobOffer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobOfferMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobOfferMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobOffer).
func (m *JobOfferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobOfferMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.title != nil {
		fields = append(fields, joboffer.FieldTitle)
	}
	if m.reference != nil {
		fields = append(fields, joboffer.FieldReference)
	}
	if m.start_date != nil {
		fields = append(fields, joboffer.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, joboffer.FieldEndDate)
	}
	if m.address1 != nil {
		fields = append(fields, joboffer.FieldAddress1)
	}
	if m.address2 != nil {
		fields = append(fields, joboffer.FieldAddress2)
	}
	if m.department != nil {
		fields = append(fields, joboffer.FieldDepartment)
	}
	if m.description != nil {
		fields = append(fields, joboffer.FieldDescription)
	}
	if m.working_hours != nil {
		fields = append(fields, joboffer.FieldWorkingHours)
	}
	if m.salary != nil {
		fields = append(fields, joboffer.FieldSalary)
	}
	if m.slug != nil {
		fields = append(fields, joboffer.FieldSlug)
	}
	if m.is_featured != nil {
		fields = append(fields, joboffer.FieldIsFeatured)
	}
	if m.has_been_emailed != nil {
		fields = append(fields, joboffer.FieldHasBeenEmailed)
	}
	if m.status != nil {
		fields = append(fields, joboffer.FieldStatusID)
	}
	if m.created_at != nil {
		fields = append(fields, joboffer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, joboffer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, joboffer.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobOfferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case joboffer.FieldTitle:
		return m.Title()
	case joboffer.FieldReference:
		return m.Reference()
	case joboffer.FieldStartDate:
		return m.StartDate()
	case joboffer.FieldEndDate:
		return m.EndDate()
	case joboffer.FieldAddress1:
		return m.Address1()
	case joboffer.FieldAddress2:
		return m.Address2()
	case joboffer.FieldDepartment:
		return m.Department()
	case joboffer.FieldDescription:
		return m.Description()
	case joboffer.FieldWorkingHours:
		return m.WorkingHours()
	case joboffer.FieldSalary:
		return m.Salary()
	case joboffer.FieldSlug:
		return m.Slug()
	case joboffer.FieldIsFeatured:
		return m.IsFeatured()
	case joboffer.FieldHasBeenEmailed:
		return m.HasBeenEmailed()
	case joboffer.FieldStatusID:
		return m.StatusID()
	case joboffer.FieldCreatedAt:
		return m.CreatedAt()
	case joboffer.FieldUpdatedAt:
		return m.UpdatedAt()
	case joboffer.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobOfferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case joboffer.FieldTitle:
		return m.OldTitle(ctx)
	case joboffer.FieldReference:
		return m.OldReference(ctx)
	case joboffer.FieldStartDate:
		return m.OldStartDate(ctx)
	case joboffer.FieldEndDate:
		return m.OldEndDate(ctx)
	case joboffer.FieldAddress1:
		return m.OldAddress1(ctx)
	case joboffer.FieldAddress2:
		return m.OldAddress2(ctx)
	case joboffer.FieldDepartment:
		return m.OldDepartment(ctx)
	case joboffer.FieldDescription:
		return m.OldDescription(ctx)
	case joboffer.FieldWorkingHours:
		return m.OldWorkingHours(ctx)
	case joboffer.FieldSalary:
		return m.OldSalary(ctx)
	case joboffer.FieldSlug:
		return m.OldSlug(ctx)
	case joboffer.FieldIsFeatured:
		return m.OldIsFeatured(ctx)
	case joboffer.FieldHasBeenEmailed:
		return m.OldHasBeenEmailed(ctx)
	case joboffer.FieldStatusID:
		return m.OldStatusID(ctx)
	case joboffer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case joboffer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case joboffer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobOffer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobOfferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case joboffer.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case joboffer.FieldReference:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReference(v)
		return nil
	case joboffer.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case joboffer.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case joboffer.FieldAddress1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress1(v)
		return nil
	case joboffer.FieldAddress2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress2(v)
		return nil
	case joboffer.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case joboffer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case joboffer.FieldWorkingHours:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkingHours(v)
		return nil
	case joboffer.FieldSalary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalary(v)
		return nil
	case joboffer.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case joboffer.FieldIsFeatured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFeatured(v)
		return nil
	case joboffer.FieldHasBeenEmailed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasBeenEmailed(v)
		return nil
	case joboffer.FieldStatusID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusID(v)
		return nil
	case joboffer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case joboffer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case joboffer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobOffer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobOfferMutation) AddedFields() []string {
	var fields []string
	if m.addreference != nil {
		fields = append(fields, joboffer.FieldReference)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobOfferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case joboffer.FieldReference:
		return m.AddedReference()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobOfferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case joboffer.FieldReference:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReference(v)
		return nil
	}
	return fmt.Errorf("unknown JobOffer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobOfferMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(joboffer.FieldAddress1) {
		fields = append(fields, joboffer.FieldAddress1)
	}
	if m.FieldCleared(joboffer.FieldAddress2) {
		fields = append(fields, joboffer.FieldAddress2)
	}
	if m.FieldCleared(joboffer.FieldIsFeatured) {
		fields = append(fields, joboffer.FieldIsFeatured)
	}
	if m.FieldCleared(joboffer.FieldHasBeenEmailed) {
		fields = append(fields, joboffer.FieldHasBeenEmailed)
	}
	if m.FieldCleared(joboffer.FieldStatusID) {
		fields = append(fields, joboffer.FieldStatusID)
	}
	if m.FieldCleared(joboffer.FieldCreatedAt) {
		fields = append(fields, joboffer.FieldCreatedAt)
	}
	if m.FieldCleared(joboffer.FieldUpdatedAt) {
		fields = append(fields, joboffer.FieldUpdatedAt)
	}
	if m.FieldCleared(joboffer.FieldDeletedAt) {
		fields = append(fields, joboffer.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobOfferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobOfferMutation) ClearField(name string) error {
	switch name {
	case joboffer.FieldAddress1:
		m.ClearAddress1()
		return nil
	case joboffer.FieldAddress2:
		m.ClearAddress2()
		return nil
	case joboffer.FieldIsFeatured:
		m.ClearIsFeatured()
		return nil
	case joboffer.FieldHasBeenEmailed:
		m.ClearHasBeenEmailed()
		return nil
	case joboffer.FieldStatusID:
		m.ClearStatusID()
		return nil
	case joboffer.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case joboffer.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case joboffer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown JobOffer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobOfferMutation) ResetField(name string) error {
	switch name {
	case joboffer.FieldTitle:
		m.ResetTitle()
		return nil
	case joboffer.FieldReference:
		m.ResetReference()
		return nil
	case joboffer.FieldStartDate:
		m.ResetStartDate()
		return nil
	case joboffer.FieldEndDate:
		m.ResetEndDate()
		return nil
	case joboffer.FieldAddress1:
		m.ResetAddress1()
		return nil
	case joboffer.FieldAddress2:
		m.ResetAddress2()
		return nil
	case joboffer.FieldDepartment:
		m.ResetDepartment()
		return nil
	case joboffer.FieldDescription:
		m.ResetDescription()
		return nil
	case joboffer.FieldWorkingHours:
		m.ResetWorkingHours()
		return nil
	case joboffer.FieldSalary:
		m.ResetSalary()
		return nil
	case joboffer.FieldSlug:
		m.ResetSlug()
		return nil
	case joboffer.FieldIsFeatured:
		m.ResetIsFeatured()
		return nil
	case joboffer.FieldHasBeenEmailed:
		m.ResetHasBeenEmailed()
		return nil
	case joboffer.FieldStatusID:
		m.ResetStatusID()
		return nil
	case joboffer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case joboffer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case joboffer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown JobOffer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobOfferMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.applications != nil {
		edges = append(edges, joboffer.EdgeApplications)
	}
	if m.job_offer_categories != nil {
		edges = append(edges, joboffer.EdgeJobOfferCategories)
	}
	if m.status != nil {
		edges = append(edges, joboffer.EdgeStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobOfferMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case joboffer.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case joboffer.EdgeJobOfferCategories:
		ids := make([]ent.Value, 0, len(m.job_offer_categories))
		for id := range m.job_offer_categories {
			ids = append(ids, id)
		}
		return ids
	case joboffer.EdgeStatus:
		if id := m.status; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobOfferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedapplications != nil {
		edges = append(edges, joboffer.EdgeApplications)
	}
	if m.removedjob_offer_categories != nil {
		edges = append(edges, joboffer.EdgeJobOfferCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobOfferMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case joboffer.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	case joboffer.EdgeJobOfferCategories:
		ids := make([]ent.Value, 0, len(m.removedjob_offer_categories))
		for id := range m.removedjob_offer_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobOfferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapplications {
		edges = append(edges, joboffer.EdgeApplications)
	}
	if m.clearedjob_offer_categories {
		edges = append(edges, joboffer.EdgeJobOfferCategories)
	}
	if m.clearedstatus {
		edges = append(edges, joboffer.EdgeStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobOfferMutation) EdgeCleared(name string) bool {
	switch name {
	case joboffer.EdgeApplications:
		return m.clearedapplications
	case joboffer.EdgeJobOfferCategories:
		return m.clearedjob_offer_categories
	case joboffer.EdgeStatus:
		return m.clearedstatus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobOfferMutation) ClearEdge(name string) error {
	switch name {
	case joboffer.EdgeStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown JobOffer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobOfferMutation) ResetEdge(name string) error {
	switch name {
	case joboffer.EdgeApplications:
		m.ResetApplications()
		return nil
	case joboffer.EdgeJobOfferCategories:
		m.ResetJobOfferCategories()
		return nil
	case joboffer.EdgeStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown JobOffer edge %s", name)
}

// JobOfferCategoryMutation represents an operation that mutates the JobOfferCategory nodes in the graph.
type JobOfferCategoryMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	clearedFields    map[string]struct{}
	category         *uuid.UUID
	clearedcategory  bool
	job_offer        *uuid.UUID
	clearedjob_offer bool
	done             bool
	oldValue         func(context.Context) (*JobOfferCategory, error)
	predicates       []predicate.JobOfferCategory
}

var _ ent.Mutation = (*JobOfferCategoryMutation)(nil)

// joboffercategoryOption allows management of the mutation configuration using functional options.
type joboffercategoryOption func(*JobOfferCategoryMutation)

// newJobOfferCategoryMutation creates new mutation for the JobOfferCategory entity.
func newJobOfferCategoryMutation(c config, op Op, opts ...joboffercategoryOption) *JobOfferCategoryMutation {
	m := &JobOfferCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeJobOfferCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobOfferCategoryID sets the ID field of the mutation.
func withJobOfferCategoryID(id uuid.UUID) joboffercategoryOption {
	return func(m *JobOfferCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *JobOfferCategory
		)
		m.oldValue = func(ctx context.Context) (*JobOfferCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobOfferCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobOfferCategory sets the old JobOfferCategory of the mutation.
func withJobOfferCategory(node *JobOfferCategory) joboffercategoryOption {
	return func(m *JobOfferCategoryMutation) {
		m.oldValue = func(context.Context) (*JobOfferCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobOfferCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobOfferCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobOfferCategory entities.
func (m *JobOfferCategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobOfferCategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobOfferCategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobOfferCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJobOfferID sets the "job_offer_id" field.
func (m *JobOfferCategoryMutation) SetJobOfferID(u uuid.UUID) {
	m.job_offer = &u
}

// JobOfferID returns the value of the "job_offer_id" field in the mutation.
func (m *JobOfferCategoryMutation) JobOfferID() (r uuid.UUID, exists bool) {
	v := m.job_offer
	if v == nil {
		return
	}
	return *v, true
}

// OldJobOfferID returns the old "job_offer_id" field's value of the JobOfferCategory entity.
// If the JobOfferCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferCategoryMutation) OldJobOfferID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobOfferID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobOfferID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobOfferID: %w", err)
	}
	return oldValue.JobOfferID, nil
}

// ResetJobOfferID resets all changes to the "job_offer_id" field.
func (m *JobOfferCategoryMutation) ResetJobOfferID() {
	m.job_offer = nil
}

// SetCategoryID sets the "category_id" field.
func (m *JobOfferCategoryMutation) SetCategoryID(u uuid.UUID) {
	m.category = &u
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *JobOfferCategoryMutation) CategoryID() (r uuid.UUID, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the JobOfferCategory entity.
// If the JobOfferCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferCategoryMutation) OldCategoryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *JobOfferCategoryMutation) ResetCategoryID() {
	m.category = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobOfferCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobOfferCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobOfferCategory entity.
// If the JobOfferCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *JobOfferCategoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[joboffercategory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *JobOfferCategoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[joboffercategory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobOfferCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, joboffercategory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobOfferCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobOfferCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobOfferCategory entity.
// If the JobOfferCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *JobOfferCategoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[joboffercategory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *JobOfferCategoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[joboffercategory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobOfferCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, joboffercategory.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobOfferCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobOfferCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the JobOfferCategory entity.
// If the JobOfferCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOfferCategoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobOfferCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[joboffercategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobOfferCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[joboffercategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobOfferCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, joboffercategory.FieldDeletedAt)
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *JobOfferCategoryMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *JobOfferCategoryMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *JobOfferCategoryMutation) CategoryIDs() (ids []uuid.UUID) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *JobOfferCategoryMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// ClearJobOffer clears the "job_offer" edge to the JobOffer entity.
func (m *JobOfferCategoryMutation) ClearJobOffer() {
	m.clearedjob_offer = true
}

// JobOfferCleared reports if the "job_offer" edge to the JobOffer entity was cleared.
func (m *JobOfferCategoryMutation) JobOfferCleared() bool {
	return m.clearedjob_offer
}

// JobOfferIDs returns the "job_offer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobOfferID instead. It exists only for internal usage by the builders.
func (m *JobOfferCategoryMutation) JobOfferIDs() (ids []uuid.UUID) {
	if id := m.job_offer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobOffer resets all changes to the "job_offer" edge.
func (m *JobOfferCategoryMutation) ResetJobOffer() {
	m.job_offer = nil
	m.clearedjob_offer = false
}

// Where appends a list predicates to the JobOfferCategoryMutation builder.
func (m *JobOfferCategoryMutation) Where(ps ...predicate.JobOfferCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobOfferCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobOfferCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobOfferCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobOfferCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobOfferCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobOfferCategory).
func (m *JobOfferCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobOfferCategoryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.job_offer != nil {
		fields = append(fields, joboffercategory.FieldJobOfferID)
	}
	if m.category != nil {
		fields = append(fields, joboffercategory.FieldCategoryID)
	}
	if m.created_at != nil {
		fields = append(fields, joboffercategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, joboffercategory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, joboffercategory.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobOfferCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case joboffercategory.FieldJobOfferID:
		return m.JobOfferID()
	case joboffercategory.FieldCategoryID:
		return m.CategoryID()
	case joboffercategory.FieldCreatedAt:
		return m.CreatedAt()
	case joboffercategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case joboffercategory.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobOfferCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case joboffercategory.FieldJobOfferID:
		return m.OldJobOfferID(ctx)
	case joboffercategory.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case joboffercategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case joboffercategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case joboffercategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobOfferCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobOfferCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case joboffercategory.FieldJobOfferID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobOfferID(v)
		return nil
	case joboffercategory.FieldCategoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case joboffercategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case joboffercategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case joboffercategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobOfferCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobOfferCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobOfferCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobOfferCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobOfferCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobOfferCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(joboffercategory.FieldCreatedAt) {
		fields = append(fields, joboffercategory.FieldCreatedAt)
	}
	if m.FieldCleared(joboffercategory.FieldUpdatedAt) {
		fields = append(fields, joboffercategory.FieldUpdatedAt)
	}
	if m.FieldCleared(joboffercategory.FieldDeletedAt) {
		fields = append(fields, joboffercategory.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobOfferCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobOfferCategoryMutation) ClearField(name string) error {
	switch name {
	case joboffercategory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case joboffercategory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case joboffercategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown JobOfferCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobOfferCategoryMutation) ResetField(name string) error {
	switch name {
	case joboffercategory.FieldJobOfferID:
		m.ResetJobOfferID()
		return nil
	case joboffercategory.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case joboffercategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case joboffercategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case joboffercategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown JobOfferCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobOfferCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.category != nil {
		edges = append(edges, joboffercategory.EdgeCategory)
	}
	if m.job_offer != nil {
		edges = append(edges, joboffercategory.EdgeJobOffer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobOfferCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case joboffercategory.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case joboffercategory.EdgeJobOffer:
		if id := m.job_offer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobOfferCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobOfferCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobOfferCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcategory {
		edges = append(edges, joboffercategory.EdgeCategory)
	}
	if m.clearedjob_offer {
		edges = append(edges, joboffercategory.EdgeJobOffer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobOfferCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case joboffercategory.EdgeCategory:
		return m.clearedcategory
	case joboffercategory.EdgeJobOffer:
		return m.clearedjob_offer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobOfferCategoryMutation) ClearEdge(name string) error {
	switch name {
	case joboffercategory.EdgeCategory:
		m.ClearCategory()
		return nil
	case joboffercategory.EdgeJobOffer:
		m.ClearJobOffer()
		return nil
	}
	return fmt.Errorf("unknown JobOfferCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobOfferCategoryMutation) ResetEdge(name string) error {
	switch name {
	case joboffercategory.EdgeCategory:
		m.ResetCategory()
		return nil
	case joboffercategory.EdgeJobOffer:
		m.ResetJobOffer()
		return nil
	}
	return fmt.Errorf("unknown JobOfferCategory edge %s", name)
}

// LanguageMutation represents an operation that mutates the Language nodes in the graph.
type LanguageMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uint
	name                     *language.Name
	level                    *language.Level
	comments                 *string
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	applicant_profile        *uuid.UUID
	clearedapplicant_profile bool
	done                     bool
	oldValue                 func(context.Context) (*Language, error)
	predicates               []predicate.Language
}

var _ ent.Mutation = (*LanguageMutation)(nil)

// languageOption allows management of the mutation configuration using functional options.
type languageOption func(*LanguageMutation)

// newLanguageMutation creates new mutation for the Language entity.
func newLanguageMutation(c config, op Op, opts ...languageOption) *LanguageMutation {
	m := &LanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLanguageID sets the ID field of the mutation.
func withLanguageID(id uint) languageOption {
	return func(m *LanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *Language
		)
		m.oldValue = func(ctx context.Context) (*Language, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Language.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLanguage sets the old Language of the mutation.
func withLanguage(node *Language) languageOption {
	return func(m *LanguageMutation) {
		m.oldValue = func(context.Context) (*Language, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Language entities.
func (m *LanguageMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LanguageMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LanguageMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Language.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LanguageMutation) SetName(l language.Name) {
	m.name = &l
}

// Name returns the value of the "name" field in the mutation.
func (m *LanguageMutation) Name() (r language.Name, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldName(ctx context.Context) (v language.Name, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LanguageMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *LanguageMutation) SetLevel(l language.Level) {
	m.level = &l
}

// Level returns the value of the "level" field in the mutation.
func (m *LanguageMutation) Level() (r language.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldLevel(ctx context.Context) (v language.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *LanguageMutation) ResetLevel() {
	m.level = nil
}

// SetComments sets the "comments" field.
func (m *LanguageMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *LanguageMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *LanguageMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[language.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *LanguageMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[language.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *LanguageMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, language.FieldComments)
}

// SetApplicantProfileID sets the "applicant_profile_id" field.
func (m *LanguageMutation) SetApplicantProfileID(u uuid.UUID) {
	m.applicant_profile = &u
}

// ApplicantProfileID returns the value of the "applicant_profile_id" field in the mutation.
func (m *LanguageMutation) ApplicantProfileID() (r uuid.UUID, exists bool) {
	v := m.applicant_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicantProfileID returns the old "applicant_profile_id" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldApplicantProfileID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicantProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicantProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicantProfileID: %w", err)
	}
	return oldValue.ApplicantProfileID, nil
}

// ResetApplicantProfileID resets all changes to the "applicant_profile_id" field.
func (m *LanguageMutation) ResetApplicantProfileID() {
	m.applicant_profile = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LanguageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LanguageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LanguageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LanguageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LanguageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LanguageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LanguageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LanguageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *LanguageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[language.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *LanguageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[language.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LanguageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, language.FieldDeletedAt)
}

// ClearApplicantProfile clears the "applicant_profile" edge to the ApplicantProfile entity.
func (m *LanguageMutation) ClearApplicantProfile() {
	m.clearedapplicant_profile = true
}

// ApplicantProfileCleared reports if the "applicant_profile" edge to the ApplicantProfile entity was cleared.
func (m *LanguageMutation) ApplicantProfileCleared() bool {
	return m.clearedapplicant_profile
}

// ApplicantProfileIDs returns the "applicant_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicantProfileID instead. It exists only for internal usage by the builders.
func (m *LanguageMutation) ApplicantProfileIDs() (ids []uuid.UUID) {
	if id := m.applicant_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplicantProfile resets all changes to the "applicant_profile" edge.
func (m *LanguageMutation) ResetApplicantProfile() {
	m.applicant_profile = nil
	m.clearedapplicant_profile = false
}

// Where appends a list predicates to the LanguageMutation builder.
func (m *LanguageMutation) Where(ps ...predicate.Language) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Language, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Language).
func (m *LanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LanguageMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, language.FieldName)
	}
	if m.level != nil {
		fields = append(fields, language.FieldLevel)
	}
	if m.comments != nil {
		fields = append(fields, language.FieldComments)
	}
	if m.applicant_profile != nil {
		fields = append(fields, language.FieldApplicantProfileID)
	}
	if m.created_at != nil {
		fields = append(fields, language.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, language.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, language.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case language.FieldName:
		return m.Name()
	case language.FieldLevel:
		return m.Level()
	case language.FieldComments:
		return m.Comments()
	case language.FieldApplicantProfileID:
		return m.ApplicantProfileID()
	case language.FieldCreatedAt:
		return m.CreatedAt()
	case language.FieldUpdatedAt:
		return m.UpdatedAt()
	case language.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case language.FieldName:
		return m.OldName(ctx)
	case language.FieldLevel:
		return m.OldLevel(ctx)
	case language.FieldComments:
		return m.OldComments(ctx)
	case language.FieldApplicantProfileID:
		return m.OldApplicantProfileID(ctx)
	case language.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case language.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case language.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Language field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case language.FieldName:
		v, ok := value.(language.Name)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case language.FieldLevel:
		v, ok := value.(language.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case language.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case language.FieldApplicantProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicantProfileID(v)
		return nil
	case language.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case language.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case language.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LanguageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LanguageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Language numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LanguageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(language.FieldComments) {
		fields = append(fields, language.FieldComments)
	}
	if m.FieldCleared(language.FieldDeletedAt) {
		fields = append(fields, language.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LanguageMutation) ClearField(name string) error {
	switch name {
	case language.FieldComments:
		m.ClearComments()
		return nil
	case language.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Language nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LanguageMutation) ResetField(name string) error {
	switch name {
	case language.FieldName:
		m.ResetName()
		return nil
	case language.FieldLevel:
		m.ResetLevel()
		return nil
	case language.FieldComments:
		m.ResetComments()
		return nil
	case language.FieldApplicantProfileID:
		m.ResetApplicantProfileID()
		return nil
	case language.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case language.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case language.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.applicant_profile != nil {
		edges = append(edges, language.EdgeApplicantProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LanguageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case language.EdgeApplicantProfile:
		if id := m.applicant_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LanguageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapplicant_profile {
		edges = append(edges, language.EdgeApplicantProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LanguageMutation) EdgeCleared(name string) bool {
	switch name {
	case language.EdgeApplicantProfile:
		return m.clearedapplicant_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LanguageMutation) ClearEdge(name string) error {
	switch name {
	case language.EdgeApplicantProfile:
		m.ClearApplicantProfile()
		return nil
	}
	return fmt.Errorf("unknown Language unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LanguageMutation) ResetEdge(name string) error {
	switch name {
	case language.EdgeApplicantProfile:
		m.ResetApplicantProfile()
		return nil
	}
	return fmt.Errorf("unknown Language edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	title                  *string
	content                *string
	slug                   *string
	is_highlighted         *bool
	is_published           *bool
	published_at           *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	preview_image          *string
	clearedFields          map[string]struct{}
	post_categories        map[uuid.UUID]struct{}
	removedpost_categories map[uuid.UUID]struct{}
	clearedpost_categories bool
	user                   *uuid.UUID
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*Post, error)
	predicates             []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id uuid.UUID) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PostMutation) ResetContent() {
	m.content = nil
}

// SetSlug sets the "slug" field.
func (m *PostMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostMutation) ResetSlug() {
	m.slug = nil
}

// SetIsHighlighted sets the "is_highlighted" field.
func (m *PostMutation) SetIsHighlighted(b bool) {
	m.is_highlighted = &b
}

// IsHighlighted returns the value of the "is_highlighted" field in the mutation.
func (m *PostMutation) IsHighlighted() (r bool, exists bool) {
	v := m.is_highlighted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHighlighted returns the old "is_highlighted" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsHighlighted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHighlighted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHighlighted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHighlighted: %w", err)
	}
	return oldValue.IsHighlighted, nil
}

// ResetIsHighlighted resets all changes to the "is_highlighted" field.
func (m *PostMutation) ResetIsHighlighted() {
	m.is_highlighted = nil
}

// SetIsPublished sets the "is_published" field.
func (m *PostMutation) SetIsPublished(b bool) {
	m.is_published = &b
}

// IsPublished returns the value of the "is_published" field in the mutation.
func (m *PostMutation) IsPublished() (r bool, exists bool) {
	v := m.is_published
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublished returns the old "is_published" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsPublished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublished: %w", err)
	}
	return oldValue.IsPublished, nil
}

// ResetIsPublished resets all changes to the "is_published" field.
func (m *PostMutation) ResetIsPublished() {
	m.is_published = nil
}

// SetPublishedAt sets the "published_at" field.
func (m *PostMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *PostMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPublishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *PostMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[post.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *PostMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *PostMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, post.FieldPublishedAt)
}

// SetAuthorID sets the "author_id" field.
func (m *PostMutation) SetAuthorID(u uuid.UUID) {
	m.user = &u
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *PostMutation) AuthorID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldAuthorID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// ClearAuthorID clears the value of the "author_id" field.
func (m *PostMutation) ClearAuthorID() {
	m.user = nil
	m.clearedFields[post.FieldAuthorID] = struct{}{}
}

// AuthorIDCleared returns if the "author_id" field was cleared in this mutation.
func (m *PostMutation) AuthorIDCleared() bool {
	_, ok := m.clearedFields[post.FieldAuthorID]
	return ok
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *PostMutation) ResetAuthorID() {
	m.user = nil
	delete(m.clearedFields, post.FieldAuthorID)
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PostMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PostMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PostMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[post.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PostMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PostMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, post.FieldDeletedAt)
}

// SetPreviewImage sets the "preview_image" field.
func (m *PostMutation) SetPreviewImage(s string) {
	m.preview_image = &s
}

// PreviewImage returns the value of the "preview_image" field in the mutation.
func (m *PostMutation) PreviewImage() (r string, exists bool) {
	v := m.preview_image
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviewImage returns the old "preview_image" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPreviewImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviewImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviewImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviewImage: %w", err)
	}
	return oldValue.PreviewImage, nil
}

// ClearPreviewImage clears the value of the "preview_image" field.
func (m *PostMutation) ClearPreviewImage() {
	m.preview_image = nil
	m.clearedFields[post.FieldPreviewImage] = struct{}{}
}

// PreviewImageCleared returns if the "preview_image" field was cleared in this mutation.
func (m *PostMutation) PreviewImageCleared() bool {
	_, ok := m.clearedFields[post.FieldPreviewImage]
	return ok
}

// ResetPreviewImage resets all changes to the "preview_image" field.
func (m *PostMutation) ResetPreviewImage() {
	m.preview_image = nil
	delete(m.clearedFields, post.FieldPreviewImage)
}

// AddPostCategoryIDs adds the "post_categories" edge to the PostCategory entity by ids.
func (m *PostMutation) AddPostCategoryIDs(ids ...uuid.UUID) {
	if m.post_categories == nil {
		m.post_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.post_categories[ids[i]] = struct{}{}
	}
}

// ClearPostCategories clears the "post_categories" edge to the PostCategory entity.
func (m *PostMutation) ClearPostCategories() {
	m.clearedpost_categories = true
}

// PostCategoriesCleared reports if the "post_categories" edge to the PostCategory entity was cleared.
func (m *PostMutation) PostCategoriesCleared() bool {
	return m.clearedpost_categories
}

// RemovePostCategoryIDs removes the "post_categories" edge to the PostCategory entity by IDs.
func (m *PostMutation) RemovePostCategoryIDs(ids ...uuid.UUID) {
	if m.removedpost_categories == nil {
		m.removedpost_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.post_categories, ids[i])
		m.removedpost_categories[ids[i]] = struct{}{}
	}
}

// RemovedPostCategories returns the removed IDs of the "post_categories" edge to the PostCategory entity.
func (m *PostMutation) RemovedPostCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedpost_categories {
		ids = append(ids, id)
	}
	return
}

// PostCategoriesIDs returns the "post_categories" edge IDs in the mutation.
func (m *PostMutation) PostCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.post_categories {
		ids = append(ids, id)
	}
	return
}

// ResetPostCategories resets all changes to the "post_categories" edge.
func (m *PostMutation) ResetPostCategories() {
	m.post_categories = nil
	m.clearedpost_categories = false
	m.removedpost_categories = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PostMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PostMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PostMutation) UserCleared() bool {
	return m.AuthorIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PostMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PostMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PostMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m.slug != nil {
		fields = append(fields, post.FieldSlug)
	}
	if m.is_highlighted != nil {
		fields = append(fields, post.FieldIsHighlighted)
	}
	if m.is_published != nil {
		fields = append(fields, post.FieldIsPublished)
	}
	if m.published_at != nil {
		fields = append(fields, post.FieldPublishedAt)
	}
	if m.user != nil {
		fields = append(fields, post.FieldAuthorID)
	}
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, post.FieldDeletedAt)
	}
	if m.preview_image != nil {
		fields = append(fields, post.FieldPreviewImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldTitle:
		return m.Title()
	case post.FieldContent:
		return m.Content()
	case post.FieldSlug:
		return m.Slug()
	case post.FieldIsHighlighted:
		return m.IsHighlighted()
	case post.FieldIsPublished:
		return m.IsPublished()
	case post.FieldPublishedAt:
		return m.PublishedAt()
	case post.FieldAuthorID:
		return m.AuthorID()
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldDeletedAt:
		return m.DeletedAt()
	case post.FieldPreviewImage:
		return m.PreviewImage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldSlug:
		return m.OldSlug(ctx)
	case post.FieldIsHighlighted:
		return m.OldIsHighlighted(ctx)
	case post.FieldIsPublished:
		return m.OldIsPublished(ctx)
	case post.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case post.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case post.FieldPreviewImage:
		return m.OldPreviewImage(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case post.FieldIsHighlighted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHighlighted(v)
		return nil
	case post.FieldIsPublished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublished(v)
		return nil
	case post.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case post.FieldAuthorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case post.FieldPreviewImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviewImage(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldPublishedAt) {
		fields = append(fields, post.FieldPublishedAt)
	}
	if m.FieldCleared(post.FieldAuthorID) {
		fields = append(fields, post.FieldAuthorID)
	}
	if m.FieldCleared(post.FieldDeletedAt) {
		fields = append(fields, post.FieldDeletedAt)
	}
	if m.FieldCleared(post.FieldPreviewImage) {
		fields = append(fields, post.FieldPreviewImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	case post.FieldAuthorID:
		m.ClearAuthorID()
		return nil
	case post.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case post.FieldPreviewImage:
		m.ClearPreviewImage()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldSlug:
		m.ResetSlug()
		return nil
	case post.FieldIsHighlighted:
		m.ResetIsHighlighted()
		return nil
	case post.FieldIsPublished:
		m.ResetIsPublished()
		return nil
	case post.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case post.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case post.FieldPreviewImage:
		m.ResetPreviewImage()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.post_categories != nil {
		edges = append(edges, post.EdgePostCategories)
	}
	if m.user != nil {
		edges = append(edges, post.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgePostCategories:
		ids := make([]ent.Value, 0, len(m.post_categories))
		for id := range m.post_categories {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpost_categories != nil {
		edges = append(edges, post.EdgePostCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgePostCategories:
		ids := make([]ent.Value, 0, len(m.removedpost_categories))
		for id := range m.removedpost_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpost_categories {
		edges = append(edges, post.EdgePostCategories)
	}
	if m.cleareduser {
		edges = append(edges, post.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgePostCategories:
		return m.clearedpost_categories
	case post.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgePostCategories:
		m.ResetPostCategories()
		return nil
	case post.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// PostCategoryMutation represents an operation that mutates the PostCategory nodes in the graph.
type PostCategoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	name                   *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	clearedFields          map[string]struct{}
	post_categories        map[uuid.UUID]struct{}
	removedpost_categories map[uuid.UUID]struct{}
	clearedpost_categories bool
	done                   bool
	oldValue               func(context.Context) (*PostCategory, error)
	predicates             []predicate.PostCategory
}

var _ ent.Mutation = (*PostCategoryMutation)(nil)

// postcategoryOption allows management of the mutation configuration using functional options.
type postcategoryOption func(*PostCategoryMutation)

// newPostCategoryMutation creates new mutation for the PostCategory entity.
func newPostCategoryMutation(c config, op Op, opts ...postcategoryOption) *PostCategoryMutation {
	m := &PostCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypePostCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostCategoryID sets the ID field of the mutation.
func withPostCategoryID(id uuid.UUID) postcategoryOption {
	return func(m *PostCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PostCategory
		)
		m.oldValue = func(ctx context.Context) (*PostCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostCategory sets the old PostCategory of the mutation.
func withPostCategory(node *PostCategory) postcategoryOption {
	return func(m *PostCategoryMutation) {
		m.oldValue = func(context.Context) (*PostCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostCategory entities.
func (m *PostCategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostCategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostCategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PostCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PostCategoryMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PostCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PostCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PostCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PostCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[postcategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PostCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PostCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, postcategory.FieldDeletedAt)
}

// AddPostCategoryIDs adds the "post_categories" edge to the PostCategory entity by ids.
func (m *PostCategoryMutation) AddPostCategoryIDs(ids ...uuid.UUID) {
	if m.post_categories == nil {
		m.post_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.post_categories[ids[i]] = struct{}{}
	}
}

// ClearPostCategories clears the "post_categories" edge to the PostCategory entity.
func (m *PostCategoryMutation) ClearPostCategories() {
	m.clearedpost_categories = true
}

// PostCategoriesCleared reports if the "post_categories" edge to the PostCategory entity was cleared.
func (m *PostCategoryMutation) PostCategoriesCleared() bool {
	return m.clearedpost_categories
}

// RemovePostCategoryIDs removes the "post_categories" edge to the PostCategory entity by IDs.
func (m *PostCategoryMutation) RemovePostCategoryIDs(ids ...uuid.UUID) {
	if m.removedpost_categories == nil {
		m.removedpost_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.post_categories, ids[i])
		m.removedpost_categories[ids[i]] = struct{}{}
	}
}

// RemovedPostCategories returns the removed IDs of the "post_categories" edge to the PostCategory entity.
func (m *PostCategoryMutation) RemovedPostCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedpost_categories {
		ids = append(ids, id)
	}
	return
}

// PostCategoriesIDs returns the "post_categories" edge IDs in the mutation.
func (m *PostCategoryMutation) PostCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.post_categories {
		ids = append(ids, id)
	}
	return
}

// ResetPostCategories resets all changes to the "post_categories" edge.
func (m *PostCategoryMutation) ResetPostCategories() {
	m.post_categories = nil
	m.clearedpost_categories = false
	m.removedpost_categories = nil
}

// Where appends a list predicates to the PostCategoryMutation builder.
func (m *PostCategoryMutation) Where(ps ...predicate.PostCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostCategory).
func (m *PostCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostCategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, postcategory.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, postcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, postcategory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, postcategory.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postcategory.FieldName:
		return m.Name()
	case postcategory.FieldCreatedAt:
		return m.CreatedAt()
	case postcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case postcategory.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postcategory.FieldName:
		return m.OldName(ctx)
	case postcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case postcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case postcategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PostCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case postcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case postcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case postcategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PostCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PostCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(postcategory.FieldDeletedAt) {
		fields = append(fields, postcategory.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostCategoryMutation) ClearField(name string) error {
	switch name {
	case postcategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PostCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostCategoryMutation) ResetField(name string) error {
	switch name {
	case postcategory.FieldName:
		m.ResetName()
		return nil
	case postcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case postcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case postcategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PostCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.post_categories != nil {
		edges = append(edges, postcategory.EdgePostCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postcategory.EdgePostCategories:
		ids := make([]ent.Value, 0, len(m.post_categories))
		for id := range m.post_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpost_categories != nil {
		edges = append(edges, postcategory.EdgePostCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case postcategory.EdgePostCategories:
		ids := make([]ent.Value, 0, len(m.removedpost_categories))
		for id := range m.removedpost_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpost_categories {
		edges = append(edges, postcategory.EdgePostCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case postcategory.EdgePostCategories:
		return m.clearedpost_categories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PostCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostCategoryMutation) ResetEdge(name string) error {
	switch name {
	case postcategory.EdgePostCategories:
		m.ResetPostCategories()
		return nil
	}
	return fmt.Errorf("unknown PostCategory edge %s", name)
}

// SkillMutation represents an operation that mutates the Skill nodes in the graph.
type SkillMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	name                            *string
	description                     *string
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	clearedFields                   map[string]struct{}
	applicant_profile_skills        map[uuid.UUID]struct{}
	removedapplicant_profile_skills map[uuid.UUID]struct{}
	clearedapplicant_profile_skills bool
	done                            bool
	oldValue                        func(context.Context) (*Skill, error)
	predicates                      []predicate.Skill
}

var _ ent.Mutation = (*SkillMutation)(nil)

// skillOption allows management of the mutation configuration using functional options.
type skillOption func(*SkillMutation)

// newSkillMutation creates new mutation for the Skill entity.
func newSkillMutation(c config, op Op, opts ...skillOption) *SkillMutation {
	m := &SkillMutation{
		config:        c,
		op:            op,
		typ:           TypeSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillID sets the ID field of the mutation.
func withSkillID(id uuid.UUID) skillOption {
	return func(m *SkillMutation) {
		var (
			err   error
			once  sync.Once
			value *Skill
		)
		m.oldValue = func(ctx context.Context) (*Skill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Skill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkill sets the old Skill of the mutation.
func withSkill(node *Skill) skillOption {
	return func(m *SkillMutation) {
		m.oldValue = func(context.Context) (*Skill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Skill entities.
func (m *SkillMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkillMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Skill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SkillMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SkillMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SkillMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SkillMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SkillMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SkillMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SkillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SkillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SkillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SkillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SkillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SkillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SkillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SkillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SkillMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[skill.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SkillMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[skill.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SkillMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, skill.FieldDeletedAt)
}

// AddApplicantProfileSkillIDs adds the "applicant_profile_skills" edge to the ApplicantProfileSkill entity by ids.
func (m *SkillMutation) AddApplicantProfileSkillIDs(ids ...uuid.UUID) {
	if m.applicant_profile_skills == nil {
		m.applicant_profile_skills = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applicant_profile_skills[ids[i]] = struct{}{}
	}
}

// ClearApplicantProfileSkills clears the "applicant_profile_skills" edge to the ApplicantProfileSkill entity.
func (m *SkillMutation) ClearApplicantProfileSkills() {
	m.clearedapplicant_profile_skills = true
}

// ApplicantProfileSkillsCleared reports if the "applicant_profile_skills" edge to the ApplicantProfileSkill entity was cleared.
func (m *SkillMutation) ApplicantProfileSkillsCleared() bool {
	return m.clearedapplicant_profile_skills
}

// RemoveApplicantProfileSkillIDs removes the "applicant_profile_skills" edge to the ApplicantProfileSkill entity by IDs.
func (m *SkillMutation) RemoveApplicantProfileSkillIDs(ids ...uuid.UUID) {
	if m.removedapplicant_profile_skills == nil {
		m.removedapplicant_profile_skills = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applicant_profile_skills, ids[i])
		m.removedapplicant_profile_skills[ids[i]] = struct{}{}
	}
}

// RemovedApplicantProfileSkills returns the removed IDs of the "applicant_profile_skills" edge to the ApplicantProfileSkill entity.
func (m *SkillMutation) RemovedApplicantProfileSkillsIDs() (ids []uuid.UUID) {
	for id := range m.removedapplicant_profile_skills {
		ids = append(ids, id)
	}
	return
}

// ApplicantProfileSkillsIDs returns the "applicant_profile_skills" edge IDs in the mutation.
func (m *SkillMutation) ApplicantProfileSkillsIDs() (ids []uuid.UUID) {
	for id := range m.applicant_profile_skills {
		ids = append(ids, id)
	}
	return
}

// ResetApplicantProfileSkills resets all changes to the "applicant_profile_skills" edge.
func (m *SkillMutation) ResetApplicantProfileSkills() {
	m.applicant_profile_skills = nil
	m.clearedapplicant_profile_skills = false
	m.removedapplicant_profile_skills = nil
}

// Where appends a list predicates to the SkillMutation builder.
func (m *SkillMutation) Where(ps ...predicate.Skill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Skill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Skill).
func (m *SkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, skill.FieldName)
	}
	if m.description != nil {
		fields = append(fields, skill.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, skill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, skill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, skill.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skill.FieldName:
		return m.Name()
	case skill.FieldDescription:
		return m.Description()
	case skill.FieldCreatedAt:
		return m.CreatedAt()
	case skill.FieldUpdatedAt:
		return m.UpdatedAt()
	case skill.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skill.FieldName:
		return m.OldName(ctx)
	case skill.FieldDescription:
		return m.OldDescription(ctx)
	case skill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case skill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case skill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Skill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skill.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case skill.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case skill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case skill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case skill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Skill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(skill.FieldDeletedAt) {
		fields = append(fields, skill.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillMutation) ClearField(name string) error {
	switch name {
	case skill.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Skill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillMutation) ResetField(name string) error {
	switch name {
	case skill.FieldName:
		m.ResetName()
		return nil
	case skill.FieldDescription:
		m.ResetDescription()
		return nil
	case skill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case skill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case skill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.applicant_profile_skills != nil {
		edges = append(edges, skill.EdgeApplicantProfileSkills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeApplicantProfileSkills:
		ids := make([]ent.Value, 0, len(m.applicant_profile_skills))
		for id := range m.applicant_profile_skills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedapplicant_profile_skills != nil {
		edges = append(edges, skill.EdgeApplicantProfileSkills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeApplicantProfileSkills:
		ids := make([]ent.Value, 0, len(m.removedapplicant_profile_skills))
		for id := range m.removedapplicant_profile_skills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapplicant_profile_skills {
		edges = append(edges, skill.EdgeApplicantProfileSkills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillMutation) EdgeCleared(name string) bool {
	switch name {
	case skill.EdgeApplicantProfileSkills:
		return m.clearedapplicant_profile_skills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Skill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillMutation) ResetEdge(name string) error {
	switch name {
	case skill.EdgeApplicantProfileSkills:
		m.ResetApplicantProfileSkills()
		return nil
	}
	return fmt.Errorf("unknown Skill edge %s", name)
}

// StatusMutation represents an operation that mutates the Status nodes in the graph.
type StatusMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	job_offers        map[uuid.UUID]struct{}
	removedjob_offers map[uuid.UUID]struct{}
	clearedjob_offers bool
	done              bool
	oldValue          func(context.Context) (*Status, error)
	predicates        []predicate.Status
}

var _ ent.Mutation = (*StatusMutation)(nil)

// statusOption allows management of the mutation configuration using functional options.
type statusOption func(*StatusMutation)

// newStatusMutation creates new mutation for the Status entity.
func newStatusMutation(c config, op Op, opts ...statusOption) *StatusMutation {
	m := &StatusMutation{
		config:        c,
		op:            op,
		typ:           TypeStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusID sets the ID field of the mutation.
func withStatusID(id uuid.UUID) statusOption {
	return func(m *StatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Status
		)
		m.oldValue = func(ctx context.Context) (*Status, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Status.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatus sets the old Status of the mutation.
func withStatus(node *Status) statusOption {
	return func(m *StatusMutation) {
		m.oldValue = func(context.Context) (*Status, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Status entities.
func (m *StatusMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatusMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatusMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Status.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StatusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StatusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StatusMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *StatusMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[status.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *StatusMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[status.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StatusMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, status.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *StatusMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[status.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *StatusMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[status.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, status.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StatusMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StatusMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StatusMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[status.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StatusMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[status.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StatusMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, status.FieldDeletedAt)
}

// AddJobOfferIDs adds the "job_offers" edge to the JobOffer entity by ids.
func (m *StatusMutation) AddJobOfferIDs(ids ...uuid.UUID) {
	if m.job_offers == nil {
		m.job_offers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.job_offers[ids[i]] = struct{}{}
	}
}

// ClearJobOffers clears the "job_offers" edge to the JobOffer entity.
func (m *StatusMutation) ClearJobOffers() {
	m.clearedjob_offers = true
}

// JobOffersCleared reports if the "job_offers" edge to the JobOffer entity was cleared.
func (m *StatusMutation) JobOffersCleared() bool {
	return m.clearedjob_offers
}

// RemoveJobOfferIDs removes the "job_offers" edge to the JobOffer entity by IDs.
func (m *StatusMutation) RemoveJobOfferIDs(ids ...uuid.UUID) {
	if m.removedjob_offers == nil {
		m.removedjob_offers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.job_offers, ids[i])
		m.removedjob_offers[ids[i]] = struct{}{}
	}
}

// RemovedJobOffers returns the removed IDs of the "job_offers" edge to the JobOffer entity.
func (m *StatusMutation) RemovedJobOffersIDs() (ids []uuid.UUID) {
	for id := range m.removedjob_offers {
		ids = append(ids, id)
	}
	return
}

// JobOffersIDs returns the "job_offers" edge IDs in the mutation.
func (m *StatusMutation) JobOffersIDs() (ids []uuid.UUID) {
	for id := range m.job_offers {
		ids = append(ids, id)
	}
	return
}

// ResetJobOffers resets all changes to the "job_offers" edge.
func (m *StatusMutation) ResetJobOffers() {
	m.job_offers = nil
	m.clearedjob_offers = false
	m.removedjob_offers = nil
}

// Where appends a list predicates to the StatusMutation builder.
func (m *StatusMutation) Where(ps ...predicate.Status) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Status, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Status).
func (m *StatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatusMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, status.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, status.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, status.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, status.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case status.FieldName:
		return m.Name()
	case status.FieldCreatedAt:
		return m.CreatedAt()
	case status.FieldUpdatedAt:
		return m.UpdatedAt()
	case status.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case status.FieldName:
		return m.OldName(ctx)
	case status.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case status.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case status.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Status field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case status.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case status.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case status.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case status.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Status numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(status.FieldCreatedAt) {
		fields = append(fields, status.FieldCreatedAt)
	}
	if m.FieldCleared(status.FieldUpdatedAt) {
		fields = append(fields, status.FieldUpdatedAt)
	}
	if m.FieldCleared(status.FieldDeletedAt) {
		fields = append(fields, status.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusMutation) ClearField(name string) error {
	switch name {
	case status.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case status.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case status.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Status nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatusMutation) ResetField(name string) error {
	switch name {
	case status.FieldName:
		m.ResetName()
		return nil
	case status.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case status.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case status.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job_offers != nil {
		edges = append(edges, status.EdgeJobOffers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeJobOffers:
		ids := make([]ent.Value, 0, len(m.job_offers))
		for id := range m.job_offers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedjob_offers != nil {
		edges = append(edges, status.EdgeJobOffers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeJobOffers:
		ids := make([]ent.Value, 0, len(m.removedjob_offers))
		for id := range m.removedjob_offers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob_offers {
		edges = append(edges, status.EdgeJobOffers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatusMutation) EdgeCleared(name string) bool {
	switch name {
	case status.EdgeJobOffers:
		return m.clearedjob_offers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Status unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatusMutation) ResetEdge(name string) error {
	switch name {
	case status.EdgeJobOffers:
		m.ResetJobOffers()
		return nil
	}
	return fmt.Errorf("unknown Status edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	email                     *string
	password                  *string
	role                      *user.Role
	reset_password_token      *string
	reset_password_expires    *time.Time
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	full_name                 *string
	salt                      *string
	external_id               *int32
	addexternal_id            *int32
	clearedFields             map[string]struct{}
	applicant_profiles        map[uuid.UUID]struct{}
	removedapplicant_profiles map[uuid.UUID]struct{}
	clearedapplicant_profiles bool
	interviews                map[uuid.UUID]struct{}
	removedinterviews         map[uuid.UUID]struct{}
	clearedinterviews         bool
	posts                     map[uuid.UUID]struct{}
	removedposts              map[uuid.UUID]struct{}
	clearedposts              bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetResetPasswordToken sets the "reset_password_token" field.
func (m *UserMutation) SetResetPasswordToken(s string) {
	m.reset_password_token = &s
}

// ResetPasswordToken returns the value of the "reset_password_token" field in the mutation.
func (m *UserMutation) ResetPasswordToken() (r string, exists bool) {
	v := m.reset_password_token
	if v == nil {
		return
	}
	return *v, true
}

// OldResetPasswordToken returns the old "reset_password_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldResetPasswordToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetPasswordToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetPasswordToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetPasswordToken: %w", err)
	}
	return oldValue.ResetPasswordToken, nil
}

// ClearResetPasswordToken clears the value of the "reset_password_token" field.
func (m *UserMutation) ClearResetPasswordToken() {
	m.reset_password_token = nil
	m.clearedFields[user.FieldResetPasswordToken] = struct{}{}
}

// ResetPasswordTokenCleared returns if the "reset_password_token" field was cleared in this mutation.
func (m *UserMutation) ResetPasswordTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldResetPasswordToken]
	return ok
}

// ResetResetPasswordToken resets all changes to the "reset_password_token" field.
func (m *UserMutation) ResetResetPasswordToken() {
	m.reset_password_token = nil
	delete(m.clearedFields, user.FieldResetPasswordToken)
}

// SetResetPasswordExpires sets the "reset_password_expires" field.
func (m *UserMutation) SetResetPasswordExpires(t time.Time) {
	m.reset_password_expires = &t
}

// ResetPasswordExpires returns the value of the "reset_password_expires" field in the mutation.
func (m *UserMutation) ResetPasswordExpires() (r time.Time, exists bool) {
	v := m.reset_password_expires
	if v == nil {
		return
	}
	return *v, true
}

// OldResetPasswordExpires returns the old "reset_password_expires" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldResetPasswordExpires(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetPasswordExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetPasswordExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetPasswordExpires: %w", err)
	}
	return oldValue.ResetPasswordExpires, nil
}

// ClearResetPasswordExpires clears the value of the "reset_password_expires" field.
func (m *UserMutation) ClearResetPasswordExpires() {
	m.reset_password_expires = nil
	m.clearedFields[user.FieldResetPasswordExpires] = struct{}{}
}

// ResetPasswordExpiresCleared returns if the "reset_password_expires" field was cleared in this mutation.
func (m *UserMutation) ResetPasswordExpiresCleared() bool {
	_, ok := m.clearedFields[user.FieldResetPasswordExpires]
	return ok
}

// ResetResetPasswordExpires resets all changes to the "reset_password_expires" field.
func (m *UserMutation) ResetResetPasswordExpires() {
	m.reset_password_expires = nil
	delete(m.clearedFields, user.FieldResetPasswordExpires)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetFullName sets the "full_name" field.
func (m *UserMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *UserMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *UserMutation) ResetFullName() {
	m.full_name = nil
}

// SetSalt sets the "salt" field.
func (m *UserMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *UserMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *UserMutation) ResetSalt() {
	m.salt = nil
}

// SetExternalID sets the "external_id" field.
func (m *UserMutation) SetExternalID(i int32) {
	m.external_id = &i
	m.addexternal_id = nil
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *UserMutation) ExternalID() (r int32, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExternalID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// AddExternalID adds i to the "external_id" field.
func (m *UserMutation) AddExternalID(i int32) {
	if m.addexternal_id != nil {
		*m.addexternal_id += i
	} else {
		m.addexternal_id = &i
	}
}

// AddedExternalID returns the value that was added to the "external_id" field in this mutation.
func (m *UserMutation) AddedExternalID() (r int32, exists bool) {
	v := m.addexternal_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExternalID clears the value of the "external_id" field.
func (m *UserMutation) ClearExternalID() {
	m.external_id = nil
	m.addexternal_id = nil
	m.clearedFields[user.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *UserMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[user.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *UserMutation) ResetExternalID() {
	m.external_id = nil
	m.addexternal_id = nil
	delete(m.clearedFields, user.FieldExternalID)
}

// AddApplicantProfileIDs adds the "applicant_profiles" edge to the ApplicantProfile entity by ids.
func (m *UserMutation) AddApplicantProfileIDs(ids ...uuid.UUID) {
	if m.applicant_profiles == nil {
		m.applicant_profiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applicant_profiles[ids[i]] = struct{}{}
	}
}

// ClearApplicantProfiles clears the "applicant_profiles" edge to the ApplicantProfile entity.
func (m *UserMutation) ClearApplicantProfiles() {
	m.clearedapplicant_profiles = true
}

// ApplicantProfilesCleared reports if the "applicant_profiles" edge to the ApplicantProfile entity was cleared.
func (m *UserMutation) ApplicantProfilesCleared() bool {
	return m.clearedapplicant_profiles
}

// RemoveApplicantProfileIDs removes the "applicant_profiles" edge to the ApplicantProfile entity by IDs.
func (m *UserMutation) RemoveApplicantProfileIDs(ids ...uuid.UUID) {
	if m.removedapplicant_profiles == nil {
		m.removedapplicant_profiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applicant_profiles, ids[i])
		m.removedapplicant_profiles[ids[i]] = struct{}{}
	}
}

// RemovedApplicantProfiles returns the removed IDs of the "applicant_profiles" edge to the ApplicantProfile entity.
func (m *UserMutation) RemovedApplicantProfilesIDs() (ids []uuid.UUID) {
	for id := range m.removedapplicant_profiles {
		ids = append(ids, id)
	}
	return
}

// ApplicantProfilesIDs returns the "applicant_profiles" edge IDs in the mutation.
func (m *UserMutation) ApplicantProfilesIDs() (ids []uuid.UUID) {
	for id := range m.applicant_profiles {
		ids = append(ids, id)
	}
	return
}

// ResetApplicantProfiles resets all changes to the "applicant_profiles" edge.
func (m *UserMutation) ResetApplicantProfiles() {
	m.applicant_profiles = nil
	m.clearedapplicant_profiles = false
	m.removedapplicant_profiles = nil
}

// AddInterviewIDs adds the "interviews" edge to the Interview entity by ids.
func (m *UserMutation) AddInterviewIDs(ids ...uuid.UUID) {
	if m.interviews == nil {
		m.interviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.interviews[ids[i]] = struct{}{}
	}
}

// ClearInterviews clears the "interviews" edge to the Interview entity.
func (m *UserMutation) ClearInterviews() {
	m.clearedinterviews = true
}

// InterviewsCleared reports if the "interviews" edge to the Interview entity was cleared.
func (m *UserMutation) InterviewsCleared() bool {
	return m.clearedinterviews
}

// RemoveInterviewIDs removes the "interviews" edge to the Interview entity by IDs.
func (m *UserMutation) RemoveInterviewIDs(ids ...uuid.UUID) {
	if m.removedinterviews == nil {
		m.removedinterviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.interviews, ids[i])
		m.removedinterviews[ids[i]] = struct{}{}
	}
}

// RemovedInterviews returns the removed IDs of the "interviews" edge to the Interview entity.
func (m *UserMutation) RemovedInterviewsIDs() (ids []uuid.UUID) {
	for id := range m.removedinterviews {
		ids = append(ids, id)
	}
	return
}

// InterviewsIDs returns the "interviews" edge IDs in the mutation.
func (m *UserMutation) InterviewsIDs() (ids []uuid.UUID) {
	for id := range m.interviews {
		ids = append(ids, id)
	}
	return
}

// ResetInterviews resets all changes to the "interviews" edge.
func (m *UserMutation) ResetInterviews() {
	m.interviews = nil
	m.clearedinterviews = false
	m.removedinterviews = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *UserMutation) AddPostIDs(ids ...uuid.UUID) {
	if m.posts == nil {
		m.posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *UserMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *UserMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *UserMutation) RemovePostIDs(ids ...uuid.UUID) {
	if m.removedposts == nil {
		m.removedposts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *UserMutation) RemovedPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *UserMutation) PostsIDs() (ids []uuid.UUID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *UserMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.reset_password_token != nil {
		fields = append(fields, user.FieldResetPasswordToken)
	}
	if m.reset_password_expires != nil {
		fields = append(fields, user.FieldResetPasswordExpires)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.full_name != nil {
		fields = append(fields, user.FieldFullName)
	}
	if m.salt != nil {
		fields = append(fields, user.FieldSalt)
	}
	if m.external_id != nil {
		fields = append(fields, user.FieldExternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldRole:
		return m.Role()
	case user.FieldResetPasswordToken:
		return m.ResetPasswordToken()
	case user.FieldResetPasswordExpires:
		return m.ResetPasswordExpires()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldFullName:
		return m.FullName()
	case user.FieldSalt:
		return m.Salt()
	case user.FieldExternalID:
		return m.ExternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldResetPasswordToken:
		return m.OldResetPasswordToken(ctx)
	case user.FieldResetPasswordExpires:
		return m.OldResetPasswordExpires(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldFullName:
		return m.OldFullName(ctx)
	case user.FieldSalt:
		return m.OldSalt(ctx)
	case user.FieldExternalID:
		return m.OldExternalID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldResetPasswordToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetPasswordToken(v)
		return nil
	case user.FieldResetPasswordExpires:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetPasswordExpires(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case user.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case user.FieldExternalID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addexternal_id != nil {
		fields = append(fields, user.FieldExternalID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldExternalID:
		return m.AddedExternalID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldExternalID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldResetPasswordToken) {
		fields = append(fields, user.FieldResetPasswordToken)
	}
	if m.FieldCleared(user.FieldResetPasswordExpires) {
		fields = append(fields, user.FieldResetPasswordExpires)
	}
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldExternalID) {
		fields = append(fields, user.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldResetPasswordToken:
		m.ClearResetPasswordToken()
		return nil
	case user.FieldResetPasswordExpires:
		m.ClearResetPasswordExpires()
		return nil
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldResetPasswordToken:
		m.ResetResetPasswordToken()
		return nil
	case user.FieldResetPasswordExpires:
		m.ResetResetPasswordExpires()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldFullName:
		m.ResetFullName()
		return nil
	case user.FieldSalt:
		m.ResetSalt()
		return nil
	case user.FieldExternalID:
		m.ResetExternalID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.applicant_profiles != nil {
		edges = append(edges, user.EdgeApplicantProfiles)
	}
	if m.interviews != nil {
		edges = append(edges, user.EdgeInterviews)
	}
	if m.posts != nil {
		edges = append(edges, user.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeApplicantProfiles:
		ids := make([]ent.Value, 0, len(m.applicant_profiles))
		for id := range m.applicant_profiles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInterviews:
		ids := make([]ent.Value, 0, len(m.interviews))
		for id := range m.interviews {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedapplicant_profiles != nil {
		edges = append(edges, user.EdgeApplicantProfiles)
	}
	if m.removedinterviews != nil {
		edges = append(edges, user.EdgeInterviews)
	}
	if m.removedposts != nil {
		edges = append(edges, user.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeApplicantProfiles:
		ids := make([]ent.Value, 0, len(m.removedapplicant_profiles))
		for id := range m.removedapplicant_profiles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInterviews:
		ids := make([]ent.Value, 0, len(m.removedinterviews))
		for id := range m.removedinterviews {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapplicant_profiles {
		edges = append(edges, user.EdgeApplicantProfiles)
	}
	if m.clearedinterviews {
		edges = append(edges, user.EdgeInterviews)
	}
	if m.clearedposts {
		edges = append(edges, user.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeApplicantProfiles:
		return m.clearedapplicant_profiles
	case user.EdgeInterviews:
		return m.clearedinterviews
	case user.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeApplicantProfiles:
		m.ResetApplicantProfiles()
		return nil
	case user.EdgeInterviews:
		m.ResetInterviews()
		return nil
	case user.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WorkExperienceMutation represents an operation that mutates the WorkExperience nodes in the graph.
type WorkExperienceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	company                  *string
	position                 *string
	description              *string
	start_date               *time.Time
	end_date                 *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	internal_comments        *string
	clearedFields            map[string]struct{}
	applicant_profile        *uuid.UUID
	clearedapplicant_profile bool
	done                     bool
	oldValue                 func(context.Context) (*WorkExperience, error)
	predicates               []predicate.WorkExperience
}

var _ ent.Mutation = (*WorkExperienceMutation)(nil)

// workexperienceOption allows management of the mutation configuration using functional options.
type workexperienceOption func(*WorkExperienceMutation)

// newWorkExperienceMutation creates new mutation for the WorkExperience entity.
func newWorkExperienceMutation(c config, op Op, opts ...workexperienceOption) *WorkExperienceMutation {
	m := &WorkExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkExperienceID sets the ID field of the mutation.
func withWorkExperienceID(id uuid.UUID) workexperienceOption {
	return func(m *WorkExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkExperience
		)
		m.oldValue = func(ctx context.Context) (*WorkExperience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkExperience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkExperience sets the old WorkExperience of the mutation.
func withWorkExperience(node *WorkExperience) workexperienceOption {
	return func(m *WorkExperienceMutation) {
		m.oldValue = func(context.Context) (*WorkExperience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkExperience entities.
func (m *WorkExperienceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkExperienceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkExperienceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkExperience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompany sets the "company" field.
func (m *WorkExperienceMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *WorkExperienceMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *WorkExperienceMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[workexperience.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *WorkExperienceMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *WorkExperienceMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, workexperience.FieldCompany)
}

// SetPosition sets the "position" field.
func (m *WorkExperienceMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *WorkExperienceMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "position" field.
func (m *WorkExperienceMutation) ClearPosition() {
	m.position = nil
	m.clearedFields[workexperience.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "position" field was cleared in this mutation.
func (m *WorkExperienceMutation) PositionCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "position" field.
func (m *WorkExperienceMutation) ResetPosition() {
	m.position = nil
	delete(m.clearedFields, workexperience.FieldPosition)
}

// SetDescription sets the "description" field.
func (m *WorkExperienceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkExperienceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkExperienceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workexperience.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkExperienceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkExperienceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workexperience.FieldDescription)
}

// SetStartDate sets the "start_date" field.
func (m *WorkExperienceMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *WorkExperienceMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *WorkExperienceMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[workexperience.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *WorkExperienceMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *WorkExperienceMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, workexperience.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *WorkExperienceMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *WorkExperienceMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *WorkExperienceMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[workexperience.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *WorkExperienceMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *WorkExperienceMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, workexperience.FieldEndDate)
}

// SetApplicantProfileID sets the "applicant_profile_id" field.
func (m *WorkExperienceMutation) SetApplicantProfileID(u uuid.UUID) {
	m.applicant_profile = &u
}

// ApplicantProfileID returns the value of the "applicant_profile_id" field in the mutation.
func (m *WorkExperienceMutation) ApplicantProfileID() (r uuid.UUID, exists bool) {
	v := m.applicant_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicantProfileID returns the old "applicant_profile_id" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldApplicantProfileID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicantProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicantProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicantProfileID: %w", err)
	}
	return oldValue.ApplicantProfileID, nil
}

// ClearApplicantProfileID clears the value of the "applicant_profile_id" field.
func (m *WorkExperienceMutation) ClearApplicantProfileID() {
	m.applicant_profile = nil
	m.clearedFields[workexperience.FieldApplicantProfileID] = struct{}{}
}

// ApplicantProfileIDCleared returns if the "applicant_profile_id" field was cleared in this mutation.
func (m *WorkExperienceMutation) ApplicantProfileIDCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldApplicantProfileID]
	return ok
}

// ResetApplicantProfileID resets all changes to the "applicant_profile_id" field.
func (m *WorkExperienceMutation) ResetApplicantProfileID() {
	m.applicant_profile = nil
	delete(m.clearedFields, workexperience.FieldApplicantProfileID)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkExperienceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkExperienceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkExperienceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkExperienceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkExperienceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkExperienceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WorkExperienceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WorkExperienceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WorkExperienceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[workexperience.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WorkExperienceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WorkExperienceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, workexperience.FieldDeletedAt)
}

// SetInternalComments sets the "internal_comments" field.
func (m *WorkExperienceMutation) SetInternalComments(s string) {
	m.internal_comments = &s
}

// InternalComments returns the value of the "internal_comments" field in the mutation.
func (m *WorkExperienceMutation) InternalComments() (r string, exists bool) {
	v := m.internal_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalComments returns the old "internal_comments" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldInternalComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalComments: %w", err)
	}
	return oldValue.InternalComments, nil
}

// ClearInternalComments clears the value of the "internal_comments" field.
func (m *WorkExperienceMutation) ClearInternalComments() {
	m.internal_comments = nil
	m.clearedFields[workexperience.FieldInternalComments] = struct{}{}
}

// InternalCommentsCleared returns if the "internal_comments" field was cleared in this mutation.
func (m *WorkExperienceMutation) InternalCommentsCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldInternalComments]
	return ok
}

// ResetInternalComments resets all changes to the "internal_comments" field.
func (m *WorkExperienceMutation) ResetInternalComments() {
	m.internal_comments = nil
	delete(m.clearedFields, workexperience.FieldInternalComments)
}

// ClearApplicantProfile clears the "applicant_profile" edge to the ApplicantProfile entity.
func (m *WorkExperienceMutation) ClearApplicantProfile() {
	m.clearedapplicant_profile = true
}

// ApplicantProfileCleared reports if the "applicant_profile" edge to the ApplicantProfile entity was cleared.
func (m *WorkExperienceMutation) ApplicantProfileCleared() bool {
	return m.ApplicantProfileIDCleared() || m.clearedapplicant_profile
}

// ApplicantProfileIDs returns the "applicant_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicantProfileID instead. It exists only for internal usage by the builders.
func (m *WorkExperienceMutation) ApplicantProfileIDs() (ids []uuid.UUID) {
	if id := m.applicant_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplicantProfile resets all changes to the "applicant_profile" edge.
func (m *WorkExperienceMutation) ResetApplicantProfile() {
	m.applicant_profile = nil
	m.clearedapplicant_profile = false
}

// Where appends a list predicates to the WorkExperienceMutation builder.
func (m *WorkExperienceMutation) Where(ps ...predicate.WorkExperience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkExperience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkExperience).
func (m *WorkExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkExperienceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.company != nil {
		fields = append(fields, workexperience.FieldCompany)
	}
	if m.position != nil {
		fields = append(fields, workexperience.FieldPosition)
	}
	if m.description != nil {
		fields = append(fields, workexperience.FieldDescription)
	}
	if m.start_date != nil {
		fields = append(fields, workexperience.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, workexperience.FieldEndDate)
	}
	if m.applicant_profile != nil {
		fields = append(fields, workexperience.FieldApplicantProfileID)
	}
	if m.created_at != nil {
		fields = append(fields, workexperience.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workexperience.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, workexperience.FieldDeletedAt)
	}
	if m.internal_comments != nil {
		fields = append(fields, workexperience.FieldInternalComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workexperience.FieldCompany:
		return m.Company()
	case workexperience.FieldPosition:
		return m.Position()
	case workexperience.FieldDescription:
		return m.Description()
	case workexperience.FieldStartDate:
		return m.StartDate()
	case workexperience.FieldEndDate:
		return m.EndDate()
	case workexperience.FieldApplicantProfileID:
		return m.ApplicantProfileID()
	case workexperience.FieldCreatedAt:
		return m.CreatedAt()
	case workexperience.FieldUpdatedAt:
		return m.UpdatedAt()
	case workexperience.FieldDeletedAt:
		return m.DeletedAt()
	case workexperience.FieldInternalComments:
		return m.InternalComments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workexperience.FieldCompany:
		return m.OldCompany(ctx)
	case workexperience.FieldPosition:
		return m.OldPosition(ctx)
	case workexperience.FieldDescription:
		return m.OldDescription(ctx)
	case workexperience.FieldStartDate:
		return m.OldStartDate(ctx)
	case workexperience.FieldEndDate:
		return m.OldEndDate(ctx)
	case workexperience.FieldApplicantProfileID:
		return m.OldApplicantProfileID(ctx)
	case workexperience.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workexperience.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workexperience.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case workexperience.FieldInternalComments:
		return m.OldInternalComments(ctx)
	}
	return nil, fmt.Errorf("unknown WorkExperience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workexperience.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case workexperience.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case workexperience.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workexperience.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case workexperience.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case workexperience.FieldApplicantProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicantProfileID(v)
		return nil
	case workexperience.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workexperience.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workexperience.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case workexperience.FieldInternalComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalComments(v)
		return nil
	}
	return fmt.Errorf("unknown WorkExperience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkExperienceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkExperienceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkExperience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkExperienceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workexperience.FieldCompany) {
		fields = append(fields, workexperience.FieldCompany)
	}
	if m.FieldCleared(workexperience.FieldPosition) {
		fields = append(fields, workexperience.FieldPosition)
	}
	if m.FieldCleared(workexperience.FieldDescription) {
		fields = append(fields, workexperience.FieldDescription)
	}
	if m.FieldCleared(workexperience.FieldStartDate) {
		fields = append(fields, workexperience.FieldStartDate)
	}
	if m.FieldCleared(workexperience.FieldEndDate) {
		fields = append(fields, workexperience.FieldEndDate)
	}
	if m.FieldCleared(workexperience.FieldApplicantProfileID) {
		fields = append(fields, workexperience.FieldApplicantProfileID)
	}
	if m.FieldCleared(workexperience.FieldDeletedAt) {
		fields = append(fields, workexperience.FieldDeletedAt)
	}
	if m.FieldCleared(workexperience.FieldInternalComments) {
		fields = append(fields, workexperience.FieldInternalComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkExperienceMutation) ClearField(name string) error {
	switch name {
	case workexperience.FieldCompany:
		m.ClearCompany()
		return nil
	case workexperience.FieldPosition:
		m.ClearPosition()
		return nil
	case workexperience.FieldDescription:
		m.ClearDescription()
		return nil
	case workexperience.FieldStartDate:
		m.ClearStartDate()
		return nil
	case workexperience.FieldEndDate:
		m.ClearEndDate()
		return nil
	case workexperience.FieldApplicantProfileID:
		m.ClearApplicantProfileID()
		return nil
	case workexperience.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case workexperience.FieldInternalComments:
		m.ClearInternalComments()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkExperienceMutation) ResetField(name string) error {
	switch name {
	case workexperience.FieldCompany:
		m.ResetCompany()
		return nil
	case workexperience.FieldPosition:
		m.ResetPosition()
		return nil
	case workexperience.FieldDescription:
		m.ResetDescription()
		return nil
	case workexperience.FieldStartDate:
		m.ResetStartDate()
		return nil
	case workexperience.FieldEndDate:
		m.ResetEndDate()
		return nil
	case workexperience.FieldApplicantProfileID:
		m.ResetApplicantProfileID()
		return nil
	case workexperience.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workexperience.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workexperience.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case workexperience.FieldInternalComments:
		m.ResetInternalComments()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.applicant_profile != nil {
		edges = append(edges, workexperience.EdgeApplicantProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkExperienceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workexperience.EdgeApplicantProfile:
		if id := m.applicant_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkExperienceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapplicant_profile {
		edges = append(edges, workexperience.EdgeApplicantProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkExperienceMutation) EdgeCleared(name string) bool {
	switch name {
	case workexperience.EdgeApplicantProfile:
		return m.clearedapplicant_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkExperienceMutation) ClearEdge(name string) error {
	switch name {
	case workexperience.EdgeApplicantProfile:
		m.ClearApplicantProfile()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkExperienceMutation) ResetEdge(name string) error {
	switch name {
	case workexperience.EdgeApplicantProfile:
		m.ResetApplicantProfile()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience edge %s", name)
}
